{% extends 'users/base.html' %}

{% block content %}
<div id="app" class="min-h-screen flex flex-col relative">

    {% include 'users/components/header.html' %}

    <!-- Main Content Area -->
    <main class="flex-1 flex flex-col">

        {% include 'users/components/auth.html' %}

        <!-- PAGE 2: Main Dashboard -->
        <div v-else-if="currentStep === 'main'" key="main" class="max-w-5xl mx-auto px-4 sm:px-6 py-8 w-full">

            {% include 'users/components/home_tab.html' %}
            {% include 'users/components/recommend_tab.html' %}
            {% include 'users/components/sale_tab.html' %}
            {% include 'users/components/community_tab.html' %}

        </div>

        {% include 'users/components/profile_tab.html' %}
    </main>

    {% include 'users/components/mobile_nav.html' %}

</div>
{% endblock %}

{% block scripts %}
<script>
    const { createApp, ref, computed, onMounted, reactive } = Vue;

    createApp({
        setup() {
            // State
            const currentStep = ref('main'); // Forced main view for logged-in users
            const currentTab = ref('home'); // 'home', 'sale'
            const isLoginMode = ref(true); // Toggle between Login and Signup
            const user = ref({ nickname: '{{ user.nickname }}', email: '{{ user.email }}' }); // Inject Django user data
            const games = ref([]);
            const wishlist = ref([]);

            // RAWG Game Tabs State
            const gameTab = ref('popular');
            const rawgGames = ref([]);
            const isLoadingGames = ref(false);

            // Community State
            const communityPosts = ref([]);
            const isWritingPost = ref(false);
            const communityCategory = ref('all');
            const selectedPost = ref(null);
            const fileInput = ref(null);
            const newPost = reactive({ title: '', content: '', category: 'free', file: null });

            // Game List Container ref for scrolling
            const gameListContainer = ref(null);

            // Auth Form State
            const authForm = reactive({
                email: '',
                password: '',
                nickname: ''
            });

            // Sorting State
            const sortBy = ref('interest');

            // Infinite Scroll State for Sale Tab
            const saleItemsPerPage = ref(10);
            const currentSaleCount = ref(10);
            const showScrollTopBtn = ref(false);
            const isLoadingMoreSales = ref(false);
            const infiniteScrollTrigger = ref(null);

            // Steam Library State
            const steamLibrary = ref([]);
            const steamTotalGames = ref(0);
            const steamTotalHours = ref(0);
            const isLoadingSteamLibrary = ref(false);

            // Recommendation State
            const recommendations = ref([]);
            const recommendSortBy = ref('score');
            const genreAnalysis = ref(null);
            const recommendationMessage = ref('');
            const isLoadingRecommendations = ref(false);
            const currentRecommendCount = ref(12);
            const recommendItemsPerPage = ref(12);
            const isLoadingMoreRecommendations = ref(false);
            const infiniteScrollTriggerRecommend = ref(null);

            onMounted(async () => {
                // Initialize Game Data from Django
                // Use verbatim block or different delimiters if mixing Vue and Django extensively
                // Here we initialize from rawSaleData for demo purposes, but ideally this comes from views.py context

                const serverData = JSON.parse('{{ games_json|escapejs }}');
                if (serverData.length > 0) {
                    games.value = serverData.map(game => ({
                        ...game,
                        matchScore: Math.floor(Math.random() * (99 - 70) + 70),
                    }));
                } else {
                    console.log("No game data found.");
                }
                // Initialize Wishlist
                try {
                    const wishlistData = JSON.parse('{{ wishlist_json|escapejs }}');
                    wishlist.value = wishlistData;
                } catch (e) {
                    console.error("Wishlist init failed", e);
                }

                // Load Default Tab Games
                await loadGameTab('popular');

                // Fetch Community Posts
                await fetchPosts();

                // Setup scroll listener for scroll-to-top button
                window.addEventListener('scroll', handleScroll);

                // Setup infinite scroll
                setupInfiniteScroll();
            });

            const loadGameTab = async (tabName) => {
                gameTab.value = tabName;
                isLoadingGames.value = true;
                rawgGames.value = [];

                try {
                    let url = '/games/api/popular/?limit=50';
                    if (tabName === 'top-rated') {
                        url = '/games/api/top-rated/?limit=50';
                    } else if (tabName === 'new-releases') {
                        url = '/games/api/new-releases/?limit=50';
                    } else if (tabName === 'trending') {
                        url = '/games/api/trending/?limit=50';
                    }

                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.games) {
                        rawgGames.value = data.games;
                    }
                } catch (e) {
                    console.error("Failed to fetch games for tab " + tabName, e);
                } finally {
                    isLoadingGames.value = false;
                    // Reset scroll position when tab changes
                    if (gameListContainer.value) {
                        gameListContainer.value.scrollLeft = 0;
                    }
                }
            };

            // Scroll game list left or right
            const scrollGameList = (direction) => {
                if (!gameListContainer.value) return;
                const container = gameListContainer.value;
                const cardWidth = 256 + 20; // w-64 (256px) + gap-5 (20px)
                const scrollAmount = cardWidth * 3; // Scroll 3 cards at a time

                if (direction === 'left') {
                    container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                } else {
                    container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                }
            };

            // --- Computed ---
            const popularGames = computed(() => games.value.slice(0, 5));

            const sortedSaleGames = computed(() => {
                let sorted = [...games.value];
                if (sortBy.value === 'interest') sorted.sort((a, b) => b.matchScore - a.matchScore);
                else if (sortBy.value === 'discount') sorted.sort((a, b) => b.discount_rate - a.discount_rate);
                else if (sortBy.value === 'price_asc') sorted.sort((a, b) => a.current_price - b.current_price);
                return sorted;
            });

            // Displayed games with infinite scroll
            const displayedSaleGames = computed(() => {
                return sortedSaleGames.value.slice(0, currentSaleCount.value);
            });

            const hasMoreSaleGames = computed(() => {
                return currentSaleCount.value < sortedSaleGames.value.length;
            });

            // Recommendation computed properties
            const sortedRecommendations = computed(() => {
                let sorted = [...recommendations.value];
                if (recommendSortBy.value === 'score') {
                    sorted.sort((a, b) => (b.recommendation_score || 0) - (a.recommendation_score || 0));
                } else if (recommendSortBy.value === 'rating') {
                    sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0));
                } else if (recommendSortBy.value === 'sale') {
                    // Show on-sale games first, then by discount
                    sorted.sort((a, b) => {
                        if (a.is_on_sale && !b.is_on_sale) return -1;
                        if (!a.is_on_sale && b.is_on_sale) return 1;
                        return (b.discount_rate || 0) - (a.discount_rate || 0);
                    });
                }
                return sorted;
            });

            const displayedRecommendations = computed(() => {
                return sortedRecommendations.value.slice(0, currentRecommendCount.value);
            });

            const hasMoreRecommendations = computed(() => {
                return currentRecommendCount.value < sortedRecommendations.value.length;
            });

            // --- Methods for CRUD & Auth ---

            const toggleAuthMode = () => {
                isLoginMode.value = !isLoginMode.value;
                authForm.email = '';
                authForm.password = '';
                authForm.nickname = '';
            };

            const handleAuthAction = () => {
                // Backend Integration Note: 
                // Replace this with axios.post('/api/login/' or '/api/register/', authForm)

                if (!authForm.email || !authForm.password) {
                    alert('이메일과 비밀번호를 입력해주세요.');
                    return;
                }
                // ... implementation details ...
            };

            const handleLogout = () => {
                // Redirect to Django logout URL
                window.location.href = "{% url 'users:logout' %}";
            };

            const deleteAccount = () => {
                // Redirect/Form submit to Django delete URL
                if (confirm("정말로 탈퇴하시겠습니까? 모든 데이터가 삭제됩니다.")) {
                    const form = document.createElement('form');
                    form.method = 'POST';
                    form.action = "{% url 'users:delete' %}";
                    const csrf = document.createElement('input');
                    csrf.type = 'hidden';
                    csrf.name = 'csrfmiddlewaretoken';
                    csrf.value = '{{ csrf_token }}';
                    form.appendChild(csrf);
                    document.body.appendChild(form);
                    form.submit();
                }
            };

            const socialLogin = (provider) => {
                alert(`${provider} 로그인 연동 기능은 준비 중입니다.`);
            };

            const toggleLink = (provider) => {
                // Toggle Linked Account Status (Update)
                if (provider === 'steam') {
                    user.value.linked_steam = !user.value.linked_steam;
                }
            };

            // --- Community Methods ---
            const fetchPosts = async () => {
                try {
                    let url = '/community/posts/';
                    if (communityCategory.value !== 'all') {
                        url += `?category=${communityCategory.value}`;
                    }
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        communityPosts.value = data.map(post => ({
                            id: post.id,
                            title: post.title,
                            content: post.content,
                            author: post.author_name || '익명',
                            category: post.category,
                            created_at: new Date(post.created_at).toLocaleDateString(),
                            likes: post.likes_count || 0,
                            comments: post.comments_count || 0,
                            image: post.image || null,
                            video: post.video || null
                        }));
                    }
                } catch (e) {
                    console.error("Failed to fetch posts", e);
                }
            };

            const handleFileUpload = (event) => {
                newPost.file = event.target.files[0];
            };

            const submitPost = async () => {
                if (!newPost.title || !newPost.content) return alert('제목과 내용을 입력해주세요.');

                try {
                    const formData = new FormData();
                    formData.append('title', newPost.title);
                    formData.append('content', newPost.content);
                    formData.append('category', newPost.category);
                    if (newPost.file) {
                        if (newPost.file.type.startsWith('image/')) {
                            formData.append('image', newPost.file);
                        } else if (newPost.file.type.startsWith('video/')) {
                            formData.append('video', newPost.file);
                        }
                    }

                    const response = await fetch('/community/posts/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: formData
                    });

                    if (response.ok) {
                        isWritingPost.value = false;
                        newPost.title = '';
                        newPost.content = '';
                        newPost.file = null;
                        if (fileInput.value) fileInput.value.value = '';
                        await fetchPosts();
                    } else {
                        alert('게시글 작성 실패');
                    }
                } catch (e) {
                    console.error(e);
                }
            };

            const openPostDetail = (post) => {
                selectedPost.value = post;
                document.body.style.overflow = 'hidden';
            };

            const closePostDetail = () => {
                selectedPost.value = null;
                document.body.style.overflow = '';
            };

            // Watch category change
            Vue.watch(communityCategory, () => {
                fetchPosts();
            });

            // --- Feature Methods ---

            const toggleWishlist = (game) => {
                const index = wishlist.value.findIndex(id => id === game.game_id);
                if (index === -1) {
                    wishlist.value.push(game.game_id);
                } else {
                    wishlist.value.splice(index, 1);
                }
            };

            const isWishlisted = (gameId) => {
                return wishlist.value.includes(gameId);
            };

            const formatPrice = (price) => price ? price.toLocaleString() : '무료';
            const handleImageError = (e) => { e.target.src = "https://via.placeholder.com/460x215?text=No+Image"; };
            const goToHome = () => {
                currentStep.value = 'main';
                currentTab.value = 'home';
            };

            const openRawgGame = (game) => {
                if (game && game.rawg_id) {
                    window.location.href = `/games/${game.rawg_id}/`;
                }
            };

            // --- Infinite Scroll Methods ---
            const scrollToTop = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            const loadMoreSaleGames = () => {
                if (isLoadingMoreSales.value || !hasMoreSaleGames.value) return;

                isLoadingMoreSales.value = true;
                setTimeout(() => {
                    currentSaleCount.value += saleItemsPerPage.value;
                    isLoadingMoreSales.value = false;
                }, 300); // Small delay for smooth UX
            };

            const setupInfiniteScroll = () => {
                // Observer for Sale tab
                const saleObserver = new IntersectionObserver((entries) => {
                    if (entries[0].isIntersecting && currentTab.value === 'sale') {
                        loadMoreSaleGames();
                    }
                }, { threshold: 0.1 });

                // Observer for Recommend tab
                const recommendObserver = new IntersectionObserver((entries) => {
                    if (entries[0].isIntersecting && currentTab.value === 'recommend') {
                        loadMoreRecommendations();
                    }
                }, { threshold: 0.1 });

                // Watch for the sale trigger element
                Vue.watch(infiniteScrollTrigger, (el) => {
                    if (el) saleObserver.observe(el);
                });

                // Watch for the recommend trigger element
                Vue.watch(infiniteScrollTriggerRecommend, (el) => {
                    if (el) recommendObserver.observe(el);
                });
            };

            // Scroll position watcher
            const handleScroll = () => {
                showScrollTopBtn.value = window.scrollY > 300;
            };

            // Reset count when items per page changes
            Vue.watch(saleItemsPerPage, (newVal) => {
                currentSaleCount.value = newVal;
            });

            // Reset count when sort changes
            Vue.watch(sortBy, () => {
                currentSaleCount.value = saleItemsPerPage.value;
            });

            // --- Steam Library Methods ---
            const fetchSteamLibrary = async () => {
                if (isLoadingSteamLibrary.value) return;

                isLoadingSteamLibrary.value = true;
                try {
                    const response = await fetch('/users/api/steam/library/');
                    if (response.ok) {
                        const data = await response.json();
                        steamLibrary.value = data.library || [];
                        steamTotalGames.value = data.total_games || 0;
                        steamTotalHours.value = data.total_playtime_hours || 0;
                    } else {
                        console.error('Failed to fetch Steam library');
                    }
                } catch (e) {
                    console.error('Error fetching Steam library:', e);
                } finally {
                    isLoadingSteamLibrary.value = false;
                }
            };

            // --- Recommendation Methods ---
            const fetchRecommendations = async () => {
                if (isLoadingRecommendations.value) return;

                isLoadingRecommendations.value = true;
                recommendations.value = [];

                try {
                    const response = await fetch('/users/api/recommendations/');
                    if (response.ok) {
                        const data = await response.json();
                        recommendations.value = data.recommendations || [];
                        genreAnalysis.value = data.genres_analysis || null;
                        recommendationMessage.value = data.message || '';
                        currentRecommendCount.value = recommendItemsPerPage.value;
                    } else {
                        console.error('Failed to fetch recommendations');
                    }
                } catch (e) {
                    console.error('Error fetching recommendations:', e);
                } finally {
                    isLoadingRecommendations.value = false;
                }
            };

            const loadMoreRecommendations = () => {
                if (isLoadingMoreRecommendations.value || !hasMoreRecommendations.value) return;

                isLoadingMoreRecommendations.value = true;
                setTimeout(() => {
                    currentRecommendCount.value += recommendItemsPerPage.value;
                    isLoadingMoreRecommendations.value = false;
                }, 300);
            };

            // Watch for tab change to load recommendations
            Vue.watch(currentTab, (newTab) => {
                if (newTab === 'recommend' && recommendations.value.length === 0) {
                    fetchRecommendations();
                }
            });

            return {
                // State
                currentStep,
                currentTab,
                user,
                authForm,
                isLoginMode,
                popularGames,
                sortedSaleGames,
                displayedSaleGames,
                hasMoreSaleGames,
                saleItemsPerPage,
                currentSaleCount,
                showScrollTopBtn,
                isLoadingMoreSales,
                infiniteScrollTrigger,
                sortBy,
                wishlist,
                gameTab,
                rawgGames,
                isLoadingGames,
                loadGameTab,
                communityPosts,
                isWritingPost,
                communityCategory,
                newPost,
                selectedPost,
                fileInput,

                // Steam Library State
                steamLibrary,
                steamTotalGames,
                steamTotalHours,
                isLoadingSteamLibrary,

                // Recommendation State
                recommendations,
                recommendSortBy,
                genreAnalysis,
                recommendationMessage,
                isLoadingRecommendations,
                sortedRecommendations,
                displayedRecommendations,
                hasMoreRecommendations,
                currentRecommendCount,
                isLoadingMoreRecommendations,
                infiniteScrollTriggerRecommend,

                // Methods
                fetchPosts,
                submitPost,
                handleFileUpload,
                openPostDetail,
                closePostDetail,

                // Methods
                toggleAuthMode,
                handleAuthAction,
                handleLogout,
                deleteAccount,
                socialLogin,
                toggleLink,
                toggleWishlist,
                isWishlisted,
                formatPrice,
                handleImageError,
                goToHome,
                openRawgGame,
                scrollToTop,
                loadMoreSaleGames,
                gameListContainer,
                scrollGameList,
                fetchSteamLibrary,
                fetchRecommendations,
                loadMoreRecommendations
            };
        }
    }).mount('#app');
</script>
{% endblock %}