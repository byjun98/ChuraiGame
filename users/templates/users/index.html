{% extends 'users/base.html' %}

{% block content %}
<div id="app" v-cloak class="min-h-screen flex flex-col relative">

    {% include 'users/components/header.html' %}

    <!-- Main Content Area -->
    <main class="flex-1 flex flex-col">

        {% include 'users/components/auth.html' %}

        <!-- PAGE 2: Main Dashboard -->
        <div v-else-if="currentStep === 'main'" key="main" class="max-w-5xl mx-auto px-4 sm:px-6 py-8 w-full">

            {% include 'users/components/home_tab.html' %}
            {% include 'users/components/recommend_tab.html' %}
            {% include 'users/components/sale_tab.html' %}
            {% include 'users/components/community_tab.html' %}
            {% include 'users/components/ai_recommend_tab.html' %}

        </div>

        {% include 'users/components/profile_tab.html' %}
    </main>

    {% include 'users/components/mobile_nav.html' %}

    <!-- Steam Experience Question Modal (í† ìŠ¤ ìŠ¤íƒ€ì¼) -->
    {% include 'users/components/steam_question_modal.html' %}

    <!-- Onboarding Modal (ì™“ì±  ìŠ¤íƒ€ì¼) -->
    {% include 'users/components/onboarding_modal.html' %}


</div>
{% endblock %}

{% block scripts %}
<script>
    const { createApp, ref, computed, onMounted, reactive } = Vue;

    createApp({
        setup() {
            // State
            const currentStep = ref('main'); // Forced main view for logged-in users
            const currentTab = ref('home'); // 'home', 'sale'
            const isLoginMode = ref(true); // Toggle between Login and Signup
            const user = ref({
                nickname: '{{ user.nickname }}',
                email: '{{ user.email }}',
                username: '{{ user.username }}',
                is_steam_linked: {% if user.is_steam_linked %}true{% else %}false{% endif %}, steam_id: '{{ user.steam_id|default:"" }}',
        avatar: '{% if user.avatar %}{{ user.avatar.url }}{% endif %}'
    }); // Inject Django user data

    const games = ref([]);
    const wishlist = ref([]);

    // RAWG Game Tabs State
    const gameTab = ref('popular');
    const rawgGames = ref([]);
    const isLoadingGames = ref(false);

    // Community State
    const communityPosts = ref([]);
    const isWritingPost = ref(false);
    const communityCategory = ref('all');
    const selectedPost = ref(null);
    const fileInput = ref(null);
    const newPost = reactive({ title: '', content: '', category: 'free', file: null });

    // Game List Container ref for scrolling
    const gameListContainer = ref(null);

    // Auth Form State
    const authForm = reactive({
        email: '',
        password: '',
        nickname: ''
    });

    // Sorting State
    const sortBy = ref('interest');

    // Infinite Scroll State for Sale Tab
    const saleItemsPerPage = ref(12);
    const currentSaleCount = ref(12);
    const saleSearchQuery = ref('');  // Search query for sale games
    const headerSearchQuery = ref('');  // Search query for header search box
    const searchSuggestions = ref([]);  // Autocomplete suggestions
    const showSearchSuggestions = ref(false);  // Show/hide autocomplete dropdown
    const searchDebounceTimer = ref(null);  // Debounce timer for search
    const showScrollTopBtn = ref(false);
    const isLoadingMoreSales = ref(false);
    const infiniteScrollTrigger = ref(null);
    const popularGamesOnSale = ref([]);  // RAWG popular games on sale
    const isLoadingPopularGames = ref(false);
    const bestPrices = ref([]);  // Best historical prices
    const bestPricesContainer = ref(null);  // Ref for best prices scroll container
    const popularGamesContainer = ref(null);  // Ref for popular games scroll container

    // Steam Library State
    const steamLibrary = ref([]);
    const steamTotalGames = ref(0);
    const steamTotalHours = ref(0);
    const isLoadingSteamLibrary = ref(false);

    // Recommendation State
    const recommendations = ref([]);
    const recommendSortBy = ref('score');
    const genreAnalysis = ref(null);
    const recommendationMessage = ref('');
    const isLoadingRecommendations = ref(false);
    const currentRecommendCount = ref(12);
    const recommendItemsPerPage = ref(12);
    const isLoadingMoreRecommendations = ref(false);
    const infiniteScrollTriggerRecommend = ref(null);

    // AI Chatbot State
    const aiChatMessages = ref([]);
    const aiUserInput = ref('');
    const isAiLoading = ref(false);
    const aiError = ref('');
    const chatContainer = ref(null);
    const aiQuickSuggestions = ref([
        'ì•¡ì…˜ RPG ì¶”ì²œí•´ì¤˜',
        'í˜¼ìž í•  ìˆ˜ ìžˆëŠ” ížë§ ê²Œìž„',
        'ìŠ¤í† ë¦¬ê°€ ì¢‹ì€ ê²Œìž„',
        'ì¹œêµ¬ëž‘ ê°™ì´ í•  ê²Œìž„',
        'ì¸ë”” ê²Œìž„ ì¶”ì²œ'
    ]);

    // Onboarding State (ì™“ì±  ìŠ¤íƒ€ì¼)
    const showOnboarding = ref(false);
    const isLoadingOnboarding = ref(false);
    const onboardingGames = ref([]);
    const onboardingRatings = ref({});  // { gameId: score }
    const onboardingCurrentStep = ref(0);
    const onboardingTotalSteps = ref(5);
    const onboardingStep = ref(null);
    // ì˜¨ë³´ë”© íŽ˜ì´ì§€ë„¤ì´ì…˜ State
    const onboardingCurrentPage = ref(1);
    const onboardingTotalPages = ref(1);
    const onboardingTotalGames = ref(0);
    const slideDirection = ref('slide-right'); // ìŠ¬ë¼ì´ë“œ ë°©í–¥: 'slide-right' ë˜ëŠ” 'slide-left'

    // Steam ê²½í—˜ ì§ˆë¬¸ ëª¨ë‹¬ State (í† ìŠ¤ ìŠ¤íƒ€ì¼)
    const showSteamQuestionModal = ref(false);
    const steamQuestionAnimating = ref(false);
    const showSteamTransitionModal = ref(false);
    const steamTransitionAnimating = ref(false);
    const onboardingKoreanMode = ref(false);  // trueë©´ í•œêµ­ ê²Œìž„ ì˜¨ë³´ë”©


    // Profile Page State
    const showWishlistModal = ref(false);
    const showReviewsModal = ref(false);
    const showSteamLibraryModal = ref(false);
    const avatarInput = ref(null);

    // Dynamic Profile State
    const targetUsername = ref(null); // If null, viewing self
    const otherUser = ref(null);
    const otherWishlist = ref([]);
    const otherRatings = ref({});
    const otherSteamLibrary = ref([]);
    const otherSteamStats = ref({ total: 0, hours: 0 });
    const isLoadingProfile = ref(false);

    // ê²Œìž„ ìƒì„¸ ì •ë³´ ìºì‹œ (ID -> Game Info)
    const gameInfoCache = ref({});


    // Genre Analysis State (Home Page)
    const genreAnalysisData = ref(null);
    const isLoadingGenreAnalysis = ref(false);

    // Steam-Style Recommendations State (Infinite Scroll)
    const steamRecommendations = ref([]);
    const steamRecommendationPage = ref(1);
    const hasMoreSteamRecommendations = ref(true);
    const isLoadingSteamRecommendations = ref(false);

    // AI Profile Generation State
    const showAiProfileModal = ref(false);
    const aiProfileUploadedImage = ref(null);  // File object
    const aiProfilePreview = ref('');  // Base64 preview URL
    const isGeneratingAiProfile = ref(false);
    const aiProfileGenerated = ref(false);
    const aiProfileResult = ref('');  // Generated image URL (base64)
    const aiProfileInput = ref(null);  // File input ref
    const userTopGenres = ref([]);  // User's favorite genres for prompt

    // Password Verification State (ê°œì¸ì •ë³´ ìˆ˜ì • ì „ ë¹„ë°€ë²ˆí˜¸ í™•ì¸)
    const showPasswordVerifyModal = ref(false);
    const verifyPassword = ref('');
    const showVerifyPassword = ref(false);
    const isVerifyingPassword = ref(false);
    const passwordVerifyError = ref('');


    // Computed: Genre Chart Gradient (Conic Gradient for Pie Chart)
    const genreChartGradient = computed(() => {
        if (!genreAnalysisData.value || !genreAnalysisData.value.genres) return 'gray';
        const genres = genreAnalysisData.value.genres;
        let gradient = 'conic-gradient(from 0deg, ';
        let currentAngle = 0;
        genres.forEach((genre, index) => {
            const angle = (genre.percentage / 100) * 360;
            gradient += `${genre.color} ${currentAngle}deg ${currentAngle + angle}deg`;
            if (index < genres.length - 1) gradient += ', ';
            currentAngle += angle;
        });
        gradient += ')';
        return gradient;
    });

    // Computed Properties for Profile Display (Switch between Me and Other)
    const isMe = computed(() => !targetUsername.value || targetUsername.value === user.value.nickname || targetUsername.value === user.value.username); // Assuming nickname is unique or we use username. API uses username. 
    // NOTE: user.value has nickname and email. It might not have 'username' explicitly if not passed from Django context. 
    // In mounted, we see: const user = ref({ nickname: '{{ user.nickname }}', email: '{{ user.email }}' });
    // We should use nickname for the URL if that's what the user asked (profile/ìœ ì €ë‹‰ë„¤ìž„).
    // But API expects username?
    // User requested: /#profile/ìœ ì €ë‹‰ë„¤ìž„ (Nickname).
    // But DB lookup is usually by username.
    // Let's assume username == nickname or we look up by username in URL.
    // Safe bet: The URL should use the identifier required by backend. The user said "User Nickname" but might mean "Identifier". 
    // Let's assume the user wants to use the unique identifier.

    const displayUser = computed(() => {
        if (isMe.value) {
            return user.value || {};
        }
        return otherUser.value || {};
    });
    const displayWishlist = computed(() => isMe.value ? wishlist.value : otherWishlist.value);
    const displayRatings = computed(() => isMe.value ? onboardingRatings.value : otherRatings.value);
    const displaySteamLibrary = computed(() => isMe.value ? steamLibrary.value : otherSteamLibrary.value);
    const displaySteamTotalGames = computed(() => isMe.value ? steamTotalGames.value : otherSteamStats.value.total);
    const displaySteamTotalHours = computed(() => isMe.value ? steamTotalHours.value : otherSteamStats.value.hours);

    // ì°œí•œ ê²Œìž„ ìƒì„¸ ì •ë³´ (ê²Œìž„ Infoì™€ ê²°í•©)
    const displayWishlistDetails = computed(() => {
        return displayWishlist.value.map(gameId => {
            // gameIdë¥¼ ë¬¸ìžì—´ë¡œ ë³€í™˜í•˜ì—¬ ìºì‹œ ì¡°íšŒ (íƒ€ìž… ì¼ì¹˜)
            const cached = gameInfoCache.value[String(gameId)];
            return {
                rawg_id: gameId,
                title: cached?.title || `ê²Œìž„ #${gameId}`,
                image_url: cached?.image_url || null,
                genre: cached?.genre || ''
            };
        });
    });

    // í‰ê°€í•œ ê²Œìž„ ìƒì„¸ ì •ë³´ (scoreì™€ ê²Œìž„ Info ê²°í•©)
    const displayRatingDetails = computed(() => {
        const ratings = displayRatings.value;
        return Object.entries(ratings)
            .filter(([_, score]) => score !== 0)
            .map(([gameId, score]) => {
                const cached = gameInfoCache.value[gameId];
                return {
                    rawg_id: gameId,
                    score: score,
                    title: cached?.title || `ê²Œìž„ #${gameId}`,
                    image_url: cached?.image_url || null,
                    genre: cached?.genre || ''
                };
            });
    });


    onMounted(async () => {
        // Initialize Game Data from Django
        // Use verbatim block or different delimiters if mixing Vue and Django extensively
        // Here we initialize from rawSaleData for demo purposes, but ideally this comes from views.py context

        const serverData = JSON.parse('{{ games_json|escapejs }}');
        if (serverData.length > 0) {
            games.value = serverData.map(game => ({
                ...game,
                matchScore: Math.floor(Math.random() * (99 - 70) + 70),
            }));
        } else {
            console.log("No game data found.");
        }
        // Initialize Wishlist
        try {
            const wishlistData = JSON.parse('{{ wishlist_json|escapejs }}');
            wishlist.value = wishlistData;
            
            // ì°œí•œ ê²Œìž„ ìƒì„¸ ì •ë³´ë¥¼ ìºì‹œì— ì €ìž¥ (ì´ˆê¸° ë¡œë“œ ì‹œ ì œëª© í‘œì‹œìš©)
            const wishlistGamesInfo = JSON.parse('{{ wishlisted_games_info_json|escapejs }}');
            Object.entries(wishlistGamesInfo).forEach(([gameId, info]) => {
                gameInfoCache.value[gameId] = info;
            });
        } catch (e) {
            console.error("Wishlist init failed", e);
        }

        // Initialize Best Prices (historic best deals)
        try {
            const bestPricesData = JSON.parse('{{ best_prices_json|escapejs }}');
            bestPrices.value = bestPricesData;
        } catch (e) {
            console.error("Best prices init failed", e);
        }

        // Fetch RAWG Popular Games for Sale tab
        fetchPopularGames();

        // URL Hash based tab navigation
        const validTabs = ['home', 'recommend', 'ai', 'sale', 'community'];

        const handleHashChange = async () => {
            const hash = window.location.hash.replace('#', '');
            if (!hash) return;

            if (validTabs.includes(hash)) {
                currentStep.value = 'main';
                currentTab.value = hash;
                targetUsername.value = null; // Reset profile view
            } else if (hash.startsWith('profile/')) {
                const username = decodeURIComponent(hash.split('/')[1]); // Handle Korean characters
                if (username) {
                    // If it's me, just switch to profile mode (fetched data is optional/optimization, but local data is fresher)
                    // But for consistency we should check if it matches my nickname?
                    // For now, fetch every time or check locally.
                    if (username === user.value.nickname || username === user.value.username) { // Assuming URL uses nickname
                        targetUsername.value = null; // Treat as 'Me'
                        currentStep.value = 'profile';
                    } else {
                        targetUsername.value = username;
                        currentStep.value = 'profile';
                        await fetchUserProfile(username);
                    }
                }
            } else if (hash === 'profile') {
                targetUsername.value = null;
                currentStep.value = 'profile';
            }
        };

        // Initial check
        handleHashChange();

        // Check URL search parameter (from detail page header search)
        const urlParams = new URLSearchParams(window.location.search);
        const searchQuery = urlParams.get('search');
        if (searchQuery) {
            saleSearchQuery.value = searchQuery;
            currentStep.value = 'main';
            currentTab.value = 'sale';
            // Clean up URL
            window.history.replaceState({}, '', window.location.pathname + window.location.hash);
        }

        // Listen for hash changes (browser back/forward)
        window.addEventListener('hashchange', handleHashChange);

        // Load Default Tab Games
        await loadGameTab('popular');

        // Fetch Community Posts
        await fetchPosts();

        // Setup scroll listener for scroll-to-top button
        window.addEventListener('scroll', handleScroll);

        // Setup infinite scroll
        setupInfiniteScroll();

        // Check if user needs onboarding (Steam ë¯¸ì—°ë™ ì‚¬ìš©ìž) - awaitìœ¼ë¡œ ratings ë°ì´í„° ë¡œë“œ ëŒ€ê¸°
        await checkOnboardingStatus();

        // Fetch Genre Analysis for Home Page
        fetchGenreAnalysis();

        // Fetch Steam-Style Recommendations
        fetchSteamRecommendations();

        // Setup Steam infinite scroll
        setupSteamInfiniteScroll();
    });

    const loadGameTab = async (tabName) => {
        gameTab.value = tabName;
        isLoadingGames.value = true;
        rawgGames.value = [];

        try {
            let url = '/games/api/popular/?limit=50';
            if (tabName === 'top-rated') {
                url = '/games/api/top-rated/?limit=50';
            } else if (tabName === 'new-releases') {
                url = '/games/api/new-releases/?limit=50';
            } else if (tabName === 'trending') {
                url = '/games/api/trending/?limit=50';
            }

            const response = await fetch(url);
            const data = await response.json();
            if (data.games) {
                // "ìš”ì¦˜ ëœ¨ëŠ”" íƒ­ì€ ë³„ì ìˆœìœ¼ë¡œ ì •ë ¬
                if (tabName === 'popular') {
                    rawgGames.value = data.games.sort((a, b) => (b.rating || 0) - (a.rating || 0));
                } else {
                    rawgGames.value = data.games;
                }
            }
        } catch (e) {
            console.error("Failed to fetch games for tab " + tabName, e);
        } finally {
            isLoadingGames.value = false;
            // Reset scroll position when tab changes
            if (gameListContainer.value) {
                gameListContainer.value.scrollLeft = 0;
            }
        }
    };

    // Scroll game list left or right
    const scrollGameList = (direction) => {
        if (!gameListContainer.value) return;
        const container = gameListContainer.value;
        const cardWidth = 256 + 20; // w-64 (256px) + gap-5 (20px)
        const scrollAmount = cardWidth * 3; // Scroll 3 cards at a time

        if (direction === 'left') {
            container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
        } else {
            container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
        }
    };

    // Fetch RAWG Popular Games and match with Steam Sale data
    const fetchPopularGames = async () => {
        if (isLoadingPopularGames.value) return;

        isLoadingPopularGames.value = true;
        try {
            // Check if sale games data is loaded
            console.log(`Sale games loaded: ${games.value.length}`);

            if (games.value.length === 0) {
                console.warn("No sale games loaded yet, cannot match");
                popularGamesOnSale.value = [];
                return;
            }

            // Fetch all-time popular games (no date filter) for sale matching
            const response = await fetch('/games/api/popular/?limit=200&all_time=true');
            const data = await response.json();

            console.log(`RAWG popular games fetched: ${data.games?.length || 0}`);

            if (data.games && data.games.length > 0) {
                // Create a map of sale games by normalized title for fast lookup
                const saleGamesMap = new Map();
                games.value.forEach(saleGame => {
                    // Normalize title: lowercase, remove special chars
                    const normalizedTitle = saleGame.title
                        .toLowerCase()
                        .replace(/[Â®â„¢Â©:!?'-]/g, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                    saleGamesMap.set(normalizedTitle, saleGame);

                    // Also try shorter version (first part before -)
                    const shortTitle = normalizedTitle.split(/[\-â€“â€”]/)[0].trim();
                    if (shortTitle.length > 3 && !saleGamesMap.has(shortTitle)) {
                        saleGamesMap.set(shortTitle, saleGame);
                    }
                });

                // Match popular games with sale data
                const matchedGames = [];
                for (const rawgGame of data.games) {
                    const normalizedRawgTitle = rawgGame.title
                        .toLowerCase()
                        .replace(/[Â®â„¢Â©:!?'-]/g, '')
                        .replace(/\s+/g, ' ')
                        .trim();

                    // Try exact match
                    let saleMatch = saleGamesMap.get(normalizedRawgTitle);

                    // Try short title match if no exact match
                    if (!saleMatch) {
                        const shortRawgTitle = normalizedRawgTitle.split(/[\-â€“â€”]/)[0].trim();
                        if (shortRawgTitle.length > 3) {
                            saleMatch = saleGamesMap.get(shortRawgTitle);
                        }
                    }

                    // Try partial match (contains)
                    if (!saleMatch) {
                        for (const [saleTitle, saleGame] of saleGamesMap) {
                            if (saleTitle.length > 5 && (normalizedRawgTitle.includes(saleTitle) || saleTitle.includes(normalizedRawgTitle))) {
                                saleMatch = saleGame;
                                break;
                            }
                        }
                    }

                    if (saleMatch) {
                        matchedGames.push({
                            ...rawgGame,
                            rawg_id: rawgGame.rawg_id || rawgGame.id,  // rawg_id ëª…ì‹œì  ë³´ìž¥
                            discount_rate: saleMatch.discount_rate || 0,
                            current_price: saleMatch.current_price || 0,
                            original_price: saleMatch.original_price || 0,
                            steam_game_id: saleMatch.game_id,
                            isOnSale: true
                        });

                        // Stop when we have enough matches
                        if (matchedGames.length >= 30) break;
                    }
                }

                popularGamesOnSale.value = matchedGames;
                console.log(`Matched ${matchedGames.length} popular games with sale data`);
            } else {
                console.warn("No games returned from RAWG API");
                popularGamesOnSale.value = [];
            }
        } catch (e) {
            console.error("Failed to fetch popular games", e);
            popularGamesOnSale.value = [];
        } finally {
            isLoadingPopularGames.value = false;
        }
    };

    // --- Computed ---
    const popularGames = computed(() => games.value.slice(0, 5));

    // Calculate recommendation score for sale games (similar to recommendation.py)
    const calculateSaleScore = (game) => {
        let score = 0;

        // 1. Steam Rating (40 points max)
        const steamRating = game.steam_rating || 0;
        if (steamRating > 0) {
            // Scale: 70-100% rating â†’ 0-40 points
            score += Math.min(40, Math.max(0, (steamRating - 70) / 30 * 40));
        }

        // 2. Review count popularity (25 points max)
        const reviewCount = game.review_count || 0;
        if (reviewCount > 0) {
            // Log scale for review count (more reviews = more trusted)
            const logReviews = Math.log10(reviewCount + 1);
            score += Math.min(25, logReviews * 5);
        }

        // 3. Discount rate (20 points max)
        const discountRate = game.discount_rate || 0;
        score += Math.min(20, discountRate * 100 * 0.2);

        // 4. Historical low bonus (15 points)
        if (game.is_historical_low) {
            score += 15;
        }

        return Math.round(score * 10) / 10;
    };

    // Filter by search query first, then sort
    const filteredSaleGames = computed(() => {
        let filtered = [...games.value];

        // Apply search filter
        if (saleSearchQuery.value.trim()) {
            const query = saleSearchQuery.value.toLowerCase().trim();
            filtered = filtered.filter(game =>
                game.title && game.title.toLowerCase().includes(query)
            );
        }

        return filtered;
    });

    const sortedSaleGames = computed(() => {
        let sorted = [...filteredSaleGames.value];

        if (sortBy.value === 'interest') {
            // Apply recommendation algorithm
            sorted = sorted.map(game => ({
                ...game,
                saleScore: calculateSaleScore(game)
            }));
            sorted.sort((a, b) => b.saleScore - a.saleScore);
        } else if (sortBy.value === 'rating') {
            sorted.sort((a, b) => (b.steam_rating || 0) - (a.steam_rating || 0));
        } else if (sortBy.value === 'discount') {
            sorted.sort((a, b) => (b.discount_rate || 0) - (a.discount_rate || 0));
        } else if (sortBy.value === 'price_asc') {
            sorted.sort((a, b) => (a.current_price || 0) - (b.current_price || 0));
        }

        return sorted;
    });

    // Displayed games with infinite scroll
    const displayedSaleGames = computed(() => {
        return sortedSaleGames.value.slice(0, currentSaleCount.value);
    });

    const hasMoreSaleGames = computed(() => {
        return currentSaleCount.value < sortedSaleGames.value.length;
    });

    // Recommendation computed properties
    const sortedRecommendations = computed(() => {
        let sorted = [...recommendations.value];
        if (recommendSortBy.value === 'score') {
            sorted.sort((a, b) => (b.recommendation_score || 0) - (a.recommendation_score || 0));
        } else if (recommendSortBy.value === 'rating') {
            sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0));
        } else if (recommendSortBy.value === 'sale') {
            // Show on-sale games first, then by discount
            sorted.sort((a, b) => {
                if (a.is_on_sale && !b.is_on_sale) return -1;
                if (!a.is_on_sale && b.is_on_sale) return 1;
                return (b.discount_rate || 0) - (a.discount_rate || 0);
            });
        }
        return sorted;
    });

    const displayedRecommendations = computed(() => {
        return sortedRecommendations.value.slice(0, currentRecommendCount.value);
    });

    const hasMoreRecommendations = computed(() => {
        return currentRecommendCount.value < sortedRecommendations.value.length;
    });

    // --- Methods for CRUD & Auth ---

    const toggleAuthMode = () => {
        isLoginMode.value = !isLoginMode.value;
        authForm.email = '';
        authForm.password = '';
        authForm.nickname = '';
    };

    const handleAuthAction = () => {
        // Backend Integration Note: 
        // Replace this with axios.post('/api/login/' or '/api/register/', authForm)

        if (!authForm.email || !authForm.password) {
            alert('ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }
        // ... implementation details ...
    };

    // Navigate to game detail page (for sale cards)
    const navigateToGameDetail = (event, gameId) => {
        // Don't navigate if user clicked on a button or link
        if (event.target.closest('a') || event.target.closest('button')) {
            return;
        }
        window.location.href = `/games/${gameId}/`;
    };

    // Navigate to Steam store page (for sale cards - Steam AppID != RAWG ID)
    const navigateToSteamStore = (event, storeLink) => {
        // Don't navigate if user clicked on a button or link
        if (event.target.closest('a') || event.target.closest('button')) {
            return;
        }
        if (storeLink) {
            window.open(storeLink, '_blank');
        }
    };

    // Navigate to game detail by title (for sale cards - search RAWG by title)
    // Now: Use rawg_id directly if available, otherwise search by title
    const navigateToGameByTitle = (event, title, steamAppId, cheapsharkUrl, rawgId = null) => {
        // Don't navigate if user clicked on a button or link
        if (event.target.closest('a') || event.target.closest('button')) {
            return;
        }

        console.log('[navigateToGameByTitle] title:', title, 'steamAppId:', steamAppId, 'rawgId:', rawgId, 'type:', typeof rawgId);

        // ìƒˆë¡œìš´ ë°©ì‹: RAWG IDê°€ ìœ íš¨í•œ ìˆ«ìžì¸ ê²½ìš°ì—ë§Œ ì§ì ‘ ìƒì„¸íŽ˜ì´ì§€ë¡œ ì´ë™
        if (rawgId && rawgId !== 'undefined' && rawgId !== 'null' && !isNaN(rawgId)) {
            window.location.href = `/games/${rawgId}/`;
            return;
        }

        // í´ë°±: ì œëª©ìœ¼ë¡œ ê²€ìƒ‰
        const params = new URLSearchParams();
        params.set('title', title);
        if (steamAppId) params.set('steam_appid', steamAppId);
        if (cheapsharkUrl) params.set('cheapshark_url', cheapsharkUrl);
        window.location.href = `/games/search/?${params.toString()}`;
    };

    // Infinite scroll for best prices (repeat items for infinite effect)
    const infiniteBestPrices = computed(() => {
        if (!bestPrices.value || bestPrices.value.length === 0) return [];
        // Repeat the list to create infinite scroll effect
        return [...bestPrices.value, ...bestPrices.value, ...bestPrices.value];
    });

    // Infinite scroll for popular games on sale (repeat items for infinite effect)
    const infinitePopularGames = computed(() => {
        if (!popularGamesOnSale.value || popularGamesOnSale.value.length === 0) return [];
        // Repeat the list to create infinite scroll effect
        return [...popularGamesOnSale.value, ...popularGamesOnSale.value, ...popularGamesOnSale.value];
    });

    // Scroll best prices list left or right
    const scrollBestPrices = (direction) => {
        if (!bestPricesContainer.value) return;
        const container = bestPricesContainer.value;
        const cardWidth = 256 + 16; // w-64 (256px) + gap-4 (16px)
        const scrollAmount = cardWidth * 3; // Scroll 3 cards at a time
        const maxScroll = container.scrollWidth - container.clientWidth;

        if (direction === 'left') {
            if (container.scrollLeft <= 0) {
                // At the beginning, jump to end
                container.scrollTo({ left: maxScroll / 2, behavior: 'auto' });
            } else {
                container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
            }
        } else {
            if (container.scrollLeft >= maxScroll - 10) {
                // At the end, jump to beginning
                container.scrollTo({ left: maxScroll / 3, behavior: 'auto' });
            } else {
                container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
            }
        }
    };

    // Scroll popular games list left or right
    const scrollPopularGames = (direction) => {
        if (!popularGamesContainer.value) return;
        const container = popularGamesContainer.value;
        const cardWidth = 288 + 16; // w-72 (288px) + gap-4 (16px)
        const scrollAmount = cardWidth * 3; // Scroll 3 cards at a time
        const maxScroll = container.scrollWidth - container.clientWidth;

        if (direction === 'left') {
            if (container.scrollLeft <= 0) {
                // At the beginning, jump to end
                container.scrollTo({ left: maxScroll / 2, behavior: 'auto' });
            } else {
                container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
            }
        } else {
            if (container.scrollLeft >= maxScroll - 10) {
                // At the end, jump to beginning
                container.scrollTo({ left: maxScroll / 3, behavior: 'auto' });
            } else {
                container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
            }
        }
    };

    // Header Search: Navigate to sale tab and search
    const performHeaderSearch = () => {
        if (headerSearchQuery.value.trim()) {
            // Hide suggestions
            showSearchSuggestions.value = false;
            // Switch to sale tab and apply search query
            currentStep.value = 'main';
            currentTab.value = 'sale';
            saleSearchQuery.value = headerSearchQuery.value.trim();
            // Clear header search after transferring
            headerSearchQuery.value = '';
            // Update URL hash
            window.location.hash = 'sale';
        }
    };

    // Header Search Autocomplete: Fetch suggestions from DB
    const onHeaderSearchInput = async () => {
        const query = headerSearchQuery.value.trim();
        
        // Clear previous timer
        if (searchDebounceTimer.value) {
            clearTimeout(searchDebounceTimer.value);
        }
        
        if (query.length < 1) {
            searchSuggestions.value = [];
            showSearchSuggestions.value = false;
            return;
        }
        
        // Debounce: wait 200ms before making API call
        searchDebounceTimer.value = setTimeout(async () => {
            try {
                const response = await fetch(`/games/api/autocomplete/?q=${encodeURIComponent(query)}&limit=10`);
                const data = await response.json();
                searchSuggestions.value = data.games || [];
                showSearchSuggestions.value = searchSuggestions.value.length > 0;
            } catch (e) {
                console.error('Autocomplete error:', e);
                searchSuggestions.value = [];
                showSearchSuggestions.value = false;
            }
        }, 200);
    };

    // Select a suggestion and navigate to game detail
    const selectSearchSuggestion = (suggestion) => {
        showSearchSuggestions.value = false;
        headerSearchQuery.value = '';
        // Navigate to game detail page
        window.location.href = `/games/${suggestion.id}/`;
    };

    // Hide suggestions with delay (for click handling)
    const hideSearchSuggestionsDelayed = () => {
        setTimeout(() => {
            showSearchSuggestions.value = false;
        }, 150);
    };

    const handleLogout = () => {
        // Redirect to Django logout URL
        window.location.href = "{% url 'users:logout' %}";
    };

    const deleteAccount = () => {
        // Redirect/Form submit to Django delete URL
        if (confirm("ì •ë§ë¡œ íƒˆí‡´í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë©ë‹ˆë‹¤.")) {
            const form = document.createElement('form');
            form.method = 'POST';
            form.action = "{% url 'users:delete' %}";
            const csrf = document.createElement('input');
            csrf.type = 'hidden';
            csrf.name = 'csrfmiddlewaretoken';
            csrf.value = '{{ csrf_token }}';
            form.appendChild(csrf);
            document.body.appendChild(form);
            form.submit();
        }
    };

    const socialLogin = (provider) => {
        alert(`${provider} ë¡œê·¸ì¸ ì—°ë™ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ìž…ë‹ˆë‹¤.`);
    };

    const toggleLink = (provider) => {
        // Toggle Linked Account Status (Update)
        if (provider === 'steam') {
            user.value.linked_steam = !user.value.linked_steam;
        }
    };

    const fetchUserProfile = async (username) => {
        isLoadingProfile.value = true;
        try {
            const response = await fetch(`/users/api/profile/${encodeURIComponent(username)}/`);
            if (response.ok) {
                const data = await response.json();

                // Check if the fetched user is actually 'me' (server side check)
                if (data.is_me) {
                    targetUsername.value = null; // Switch back to 'Me' mode
                    return;
                }

                otherUser.value = {
                    nickname: data.nickname, // Use nickname for display
                    email: data.email,
                    avatar: data.avatar,
                    is_steam_linked: data.is_steam_linked,
                    steam_id: data.steam_id,
                    username: data.username
                };
                otherWishlist.value = data.wishlist;
                otherRatings.value = data.onboardingRatings;
                otherSteamStats.value = {
                    total: data.steamTotalGames,
                    hours: data.steamTotalHours
                };
                otherSteamLibrary.value = data.steamLibrary;

                // Populate Game Info Cache (for public profile display)
                if (data.rated_games_info) {
                    Object.entries(data.rated_games_info).forEach(([id, info]) => {
                        gameInfoCache.value[id] = info;
                    });
                }
                if (data.wishlisted_games_info) {
                    Object.entries(data.wishlisted_games_info).forEach(([id, info]) => {
                        gameInfoCache.value[id] = info;
                    });
                }

            } else {
                console.error("User not found");
                // Redirect to main or show error
                alert("ì‚¬ìš©ìžë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                window.location.hash = '';
                currentStep.value = 'main';
            }
        } catch (e) {
            console.error("Fetch profile failed", e);
        } finally {
            isLoadingProfile.value = false;
        }
    };

    // --- Community Methods ---
    const newComment = ref('');
    const showShareToast = ref(false);

    const fetchPosts = async () => {
        try {
            let url = '/community/posts/';
            if (communityCategory.value !== 'all') {
                url += `?category=${communityCategory.value}`;
            }
            const response = await fetch(url);
            if (response.ok) {
                const data = await response.json();
                communityPosts.value = data.map(post => ({
                    id: post.id,
                    title: post.title,
                    content: post.content,
                    author: post.author_name || 'ìµëª…',
                    category: post.category,
                    created_at: new Date(post.created_at).toLocaleDateString(),
                    likes: post.likes_count || 0,
                    comments_count: post.comments_count || 0,
                    comments: (post.comments || []).map(c => ({
                        ...c,
                        is_own: c.author_name === user.value.nickname
                    })),
                    image_url: post.image_url || null,
                    video: post.video || null,
                    is_liked: post.is_liked || false
                }));
            }
        } catch (e) {
            console.error("Failed to fetch posts", e);
        }
    };

    const handleFileUpload = (event) => {
        newPost.file = event.target.files[0];
    };

    const submitPost = async () => {
        if (!newPost.title || !newPost.content) return alert('ì œëª©ê³¼ ë‚´ìš©ì„ ìž…ë ¥í•´ì£¼ì„¸ìš”.');

        try {
            const formData = new FormData();
            formData.append('title', newPost.title);
            formData.append('content', newPost.content);
            formData.append('category', newPost.category);
            if (newPost.file) {
                if (newPost.file.type.startsWith('image/')) {
                    formData.append('image', newPost.file);
                } else if (newPost.file.type.startsWith('video/')) {
                    formData.append('video', newPost.file);
                }
            }

            const response = await fetch('/community/posts/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: formData
            });

            if (response.ok) {
                isWritingPost.value = false;
                newPost.title = '';
                newPost.content = '';
                newPost.file = null;
                if (fileInput.value) fileInput.value.value = '';
                await fetchPosts();
            } else {
                alert('ê²Œì‹œê¸€ ìž‘ì„± ì‹¤íŒ¨');
            }
        } catch (e) {
            console.error(e);
        }
    };

    const openPostDetail = async (post) => {
        // Fetch full post detail with comments
        try {
            const response = await fetch(`/community/posts/${post.id}/`);
            if (response.ok) {
                const data = await response.json();
                selectedPost.value = {
                    id: data.id,
                    title: data.title,
                    content: data.content,
                    author: data.author_name || 'ìµëª…',
                    category: data.category,
                    created_at: new Date(data.created_at).toLocaleDateString(),
                    likes: data.likes_count || 0,
                    comments: (data.comments || []).map(c => ({
                        ...c,
                        is_own: c.author_name === user.value.nickname
                    })),
                    image_url: data.image_url || null,
                    video: data.video || null,
                    is_liked: data.is_liked || false
                };
            }
        } catch (e) {
            console.error("Failed to fetch post detail", e);
            selectedPost.value = post;
        }
        document.body.style.overflow = 'hidden';
    };

    const closePostDetail = () => {
        selectedPost.value = null;
        newComment.value = '';
        document.body.style.overflow = '';
    };

    const submitComment = async () => {
        if (!newComment.value.trim() || !selectedPost.value) return;

        try {
            const response = await fetch(`/community/posts/${selectedPost.value.id}/comments/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ content: newComment.value })
            });

            if (response.ok) {
                const comment = await response.json();
                selectedPost.value.comments.push({
                    ...comment,
                    is_own: true
                });
                newComment.value = '';
                // Update the post in the list
                const postIndex = communityPosts.value.findIndex(p => p.id === selectedPost.value.id);
                if (postIndex !== -1) {
                    communityPosts.value[postIndex].comments_count++;
                }
            } else {
                alert('ëŒ“ê¸€ ìž‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (e) {
            console.error("Failed to submit comment", e);
        }
    };

    const deleteComment = async (commentId) => {
        if (!confirm('ëŒ“ê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

        try {
            const response = await fetch(`/community/posts/${selectedPost.value.id}/comments/${commentId}/`, {
                method: 'DELETE',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (response.ok) {
                selectedPost.value.comments = selectedPost.value.comments.filter(c => c.id !== commentId);
                // Update the post in the list
                const postIndex = communityPosts.value.findIndex(p => p.id === selectedPost.value.id);
                if (postIndex !== -1) {
                    communityPosts.value[postIndex].comments_count--;
                }
            } else {
                alert('ëŒ“ê¸€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (e) {
            console.error("Failed to delete comment", e);
        }
    };

    const togglePostLike = async () => {
        if (!selectedPost.value) return;

        try {
            const response = await fetch(`/community/posts/${selectedPost.value.id}/like/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (response.ok) {
                const data = await response.json();
                selectedPost.value.is_liked = data.is_liked;
                selectedPost.value.likes = data.likes_count;
                // Update the post in the list
                const postIndex = communityPosts.value.findIndex(p => p.id === selectedPost.value.id);
                if (postIndex !== -1) {
                    communityPosts.value[postIndex].is_liked = data.is_liked;
                    communityPosts.value[postIndex].likes = data.likes_count;
                }
            }
        } catch (e) {
            console.error("Failed to toggle like", e);
        }
    };

    const sharePost = async () => {
        if (!selectedPost.value) return;

        const shareUrl = `${window.location.origin}/community/posts/${selectedPost.value.id}/`;

        try {
            await navigator.clipboard.writeText(shareUrl);
            showShareToast.value = true;
            setTimeout(() => {
                showShareToast.value = false;
            }, 2000);
        } catch (e) {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = shareUrl;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showShareToast.value = true;
            setTimeout(() => {
                showShareToast.value = false;
            }, 2000);
        }
    };

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleDateString();
    };

    // Watch category change
    Vue.watch(communityCategory, () => {
        fetchPosts();
    });

    // --- Feature Methods ---

    const toggleWishlist = async (game) => {
        // game can have: rawg_id, game_id, steam_appid, title, background_image/image
        const rawgId = game.rawg_id || game.id;
        const gameTitle = game.title || game.name || `Game ${rawgId}`;
        const gameImage = game.background_image || game.image || game.image_url || '';

        try {
            // Use RAWG-based API for all games (auto-creates game if needed)
            const response = await fetch(`/games/api/wishlist/${rawgId}/toggle/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    game_title: gameTitle,
                    game_image: gameImage
                })
            });

            if (response.ok) {
                const data = await response.json();
                // Update local state based on server response
                if (data.is_wishlisted) {
                    // Add to wishlist if not already present
                    if (!wishlist.value.includes(rawgId)) {
                        wishlist.value.push(rawgId);
                    }
                } else {
                    // Remove from wishlist
                    const index = wishlist.value.indexOf(rawgId);
                    if (index !== -1) {
                        wishlist.value.splice(index, 1);
                    }
                }
            } else {
                console.error('Failed to toggle wishlist:', await response.text());
            }
        } catch (e) {
            console.error('Wishlist toggle error:', e);
            // Fallback to local-only toggle for offline experience
            const index = wishlist.value.findIndex(id => id === rawgId);
            if (index === -1) {
                wishlist.value.push(rawgId);
            } else {
                wishlist.value.splice(index, 1);
            }
        }
    };

    const isWishlisted = (gameId) => {
        return wishlist.value.includes(gameId);
    };

    const formatPrice = (price) => price ? price.toLocaleString() : 'ë¬´ë£Œ';
    const formatReviewCount = (count) => {
        if (!count) return '0';
        if (count >= 100000) return Math.round(count / 1000) + 'K';
        if (count >= 10000) return (count / 1000).toFixed(1) + 'K';
        if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
        return count.toLocaleString();
    };
    const handleImageError = (e) => {
        // ì™¸ë¶€ ì„œë²„ ì˜ì¡´ì„± ì œê±°: SVG data URIë¡œ í´ë°± (íšŒìƒ‰ ë°°ê²½ + ê²Œìž„ ì•„ì´ì½˜)
        e.target.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='460' height='215' viewBox='0 0 460 215'%3E%3Crect fill='%23e5e7eb' width='460' height='215'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='sans-serif' font-size='16' fill='%239ca3af'%3EðŸŽ® No Image%3C/text%3E%3C/svg%3E";
    };
    const goToHome = () => {
        currentStep.value = 'main';
        currentTab.value = 'home';
        window.location.hash = '';
    };

    const goToProfile = () => {
        targetUsername.value = null; // View my own profile
        currentStep.value = 'profile';
        window.location.hash = 'profile';
    };

    const openRawgGame = (game) => {
        if (!game) return;

        console.log('[DEBUG openRawgGame] game object:', game);

        // RAWG APIì—ì„œëŠ” 'id', DBì—ì„œëŠ” 'rawg_id' ì‚¬ìš©
        const gameId = game.rawg_id || game.id;
        const gameTitle = game.title || game.name;

        console.log('[DEBUG openRawgGame] gameId:', gameId, 'gameTitle:', gameTitle);

        // IDê°€ ìžˆìœ¼ë©´ ìƒì„¸ íŽ˜ì´ì§€ë¡œ
        if (gameId) {
            const url = `/games/${gameId}/`;
            console.log('[DEBUG openRawgGame] Navigating to:', url);
            window.location.href = url;
        }
        // IDê°€ ì—†ìœ¼ë©´ ì œëª©ìœ¼ë¡œ ê²€ìƒ‰
        else if (gameTitle) {
            const params = new URLSearchParams({ title: gameTitle });
            const url = `/games/search/?${params.toString()}`;
            console.log('[DEBUG openRawgGame] Navigating (search) to:', url);
            window.location.href = url;
        }
        else {
            console.error('Game has no id or title:', game);
        }
    };


    // --- Infinite Scroll Methods ---
    const scrollToTop = () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

    const loadMoreSaleGames = () => {
        if (isLoadingMoreSales.value || !hasMoreSaleGames.value) return;

        isLoadingMoreSales.value = true;
        setTimeout(() => {
            currentSaleCount.value += saleItemsPerPage.value;
            isLoadingMoreSales.value = false;
        }, 300); // Small delay for smooth UX
    };

    const setupInfiniteScroll = () => {
        // Observer for Sale tab
        const saleObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && currentTab.value === 'sale') {
                loadMoreSaleGames();
            }
        }, { threshold: 0.1 });

        // Observer for Recommend tab
        const recommendObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && currentTab.value === 'recommend') {
                loadMoreRecommendations();
            }
        }, { threshold: 0.1 });

        // Watch for the sale trigger element
        Vue.watch(infiniteScrollTrigger, (el) => {
            if (el) saleObserver.observe(el);
        });

        // Watch for the recommend trigger element
        Vue.watch(infiniteScrollTriggerRecommend, (el) => {
            if (el) recommendObserver.observe(el);
        });
    };

    // Scroll position watcher
    const handleScroll = () => {
        showScrollTopBtn.value = window.scrollY > 300;
    };

    // Reset count when items per page changes
    Vue.watch(saleItemsPerPage, (newVal) => {
        currentSaleCount.value = newVal;
    });

    // Reset count when sort changes
    Vue.watch(sortBy, () => {
        currentSaleCount.value = saleItemsPerPage.value;
    });

    // Reset count when search query changes
    Vue.watch(saleSearchQuery, () => {
        currentSaleCount.value = saleItemsPerPage.value;
    });

    // --- Steam Library Methods ---
    const fetchSteamLibrary = async () => {
        if (isLoadingSteamLibrary.value) return;

        isLoadingSteamLibrary.value = true;
        try {
            const response = await fetch('/users/api/steam/library/');
            if (response.ok) {
                const data = await response.json();
                steamLibrary.value = data.library || [];
                steamTotalGames.value = data.total_games || 0;
                steamTotalHours.value = data.total_playtime_hours || 0;
            } else {
                console.error('Failed to fetch Steam library');
            }
        } catch (e) {
            console.error('Error fetching Steam library:', e);
        } finally {
            isLoadingSteamLibrary.value = false;
        }
    };

    // --- Recommendation Methods ---
    const fetchRecommendations = async () => {
        if (isLoadingRecommendations.value) return;

        isLoadingRecommendations.value = true;
        recommendations.value = [];

        try {
            const response = await fetch('/users/api/recommendations/');
            if (response.ok) {
                const data = await response.json();
                recommendations.value = data.recommendations || [];
                genreAnalysis.value = data.genres_analysis || null;
                recommendationMessage.value = data.message || '';
                currentRecommendCount.value = recommendItemsPerPage.value;
            } else {
                console.error('Failed to fetch recommendations');
            }
        } catch (e) {
            console.error('Error fetching recommendations:', e);
        } finally {
            isLoadingRecommendations.value = false;
        }
    };

    const loadMoreRecommendations = () => {
        if (isLoadingMoreRecommendations.value || !hasMoreRecommendations.value) return;

        isLoadingMoreRecommendations.value = true;
        setTimeout(() => {
            currentRecommendCount.value += recommendItemsPerPage.value;
            isLoadingMoreRecommendations.value = false;
        }, 300);
    };

    // --- Genre Analysis Methods (Home Page) ---
    const fetchGenreAnalysis = async () => {
        if (isLoadingGenreAnalysis.value) return;

        isLoadingGenreAnalysis.value = true;
        try {
            const response = await fetch('/users/api/genre-analysis/');
            if (response.ok) {
                const data = await response.json();
                genreAnalysisData.value = data;
            }
        } catch (e) {
            console.error('Error fetching genre analysis:', e);
        } finally {
            isLoadingGenreAnalysis.value = false;
        }
    };

    // --- Steam-Style Recommendations Methods ---
    const steamScrollTrigger = ref(null);

    const fetchSteamRecommendations = async () => {
        if (isLoadingSteamRecommendations.value) return;

        isLoadingSteamRecommendations.value = true;
        steamRecommendationPage.value = 1;
        steamRecommendations.value = [];

        try {
            // Load 3 items initially to ensure scrollbar appears/trigger moves
            const response = await fetch(`/users/api/steam-recommendations/?page=1&per_page=3`);
            if (response.ok) {
                const data = await response.json();
                steamRecommendations.value = data.recommendations || [];
                hasMoreSteamRecommendations.value = data.has_more;
                // If we loaded 3, set page to 1 (API might treat page 1 as offset 0..N).
                // Wait, python views.py: start = (page - 1) * per_page
                // If I request page=1, per_page=3. I get items 0, 1, 2.
                // Next load: loadMore uses steamRecommendationPage += 1.
                // It will request page=2, per_page=1.
                // start = (2-1)*1 = 1.
                // items 1..2.
                // DUPLICATE ITEMS!

                // Correction: The pagination logic on server is standard.
                // If I change initial load to per_page=3, I must adjust the next page / offset logic OR just use same per_page.
                // Or I should manually manage offsets.

                // Server logic:
                // start = (page - 1) * per_page

                // Client logic:
                // steamRecommendationPage increments.

                // If I mix per_page, I break the pagination alignment.
                // Fix: keep per_page consistent OR adjust page number.

                // If I fetch page 1 with per_page=3. Items 0, 1, 2.
                // Next, I want item 3.
                // If I request page=X with per_page=1.
                // I need start=3.
                // (page-1)*1 = 3 => page-1=3 => page=4.

                // So if initial load is 3 items, the next "page" for per_page=1 is 4.
                steamRecommendationPage.value = 3;
            }
        } catch (e) {
            console.error('Error fetching steam recommendations:', e);
        } finally {
            isLoadingSteamRecommendations.value = false;
        }
    };

    const loadMoreSteamRecommendations = async () => {
        if (isLoadingSteamRecommendations.value || !hasMoreSteamRecommendations.value) return;

        isLoadingSteamRecommendations.value = true;
        steamRecommendationPage.value += 1;

        try {
            const response = await fetch(`/users/api/steam-recommendations/?page=${steamRecommendationPage.value}&per_page=1`);
            if (response.ok) {
                const data = await response.json();
                steamRecommendations.value = [...steamRecommendations.value, ...(data.recommendations || [])];
                hasMoreSteamRecommendations.value = data.has_more;
            }
        } catch (e) {
            console.error('Error loading more steam recommendations:', e);
        } finally {
            isLoadingSteamRecommendations.value = false;
        }
    };

    // Hide/Remove a recommendation from the list
    const hideRecommendation = (index) => {
        steamRecommendations.value.splice(index, 1);
        // Load more if we have less than 2 visible
        if (steamRecommendations.value.length < 2 && hasMoreSteamRecommendations.value) {
            loadMoreSteamRecommendations();
        }
    };

    // --- AI Profile Generation Methods ---
    const handleAiProfileUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
            aiProfileUploadedImage.value = file;
            // Create preview URL
            const reader = new FileReader();
            reader.onload = (e) => {
                aiProfilePreview.value = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    };

    const handleAiProfileDrop = (event) => {
        const file = event.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
            aiProfileUploadedImage.value = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                aiProfilePreview.value = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    };

    const removeAiProfileImage = () => {
        aiProfileUploadedImage.value = null;
        aiProfilePreview.value = '';
    };

    const generateAiProfile = async (auto = false) => {
        isGeneratingAiProfile.value = true;
        aiProfileGenerated.value = false;
        
        try {
            // Build prompt based on user data
            const nickname = user.value.nickname || 'ê²Œì´ë¨¸';
            const genres = userTopGenres.value.length > 0 ? userTopGenres.value.slice(0, 3).join(', ') : 'RPG, ì•¡ì…˜';
            
            // Base prompt (as specified by user)
            let prompt = `Create a 3D game character illustration in Animal Crossing / Fantasy Life style.

IMPORTANT RULES:
- DO NOT add ANY text, letters, words, or characters to the image
- NO Korean text, NO English text, NO numbers
- NO watermarks, NO signatures, NO labels
- ONLY draw the character and background, absolutely NO TEXT

Style: Warm, cozy, 3D rendered game character like Animal Crossing or Fantasy Life
Background: Match the game genre theme (${genres})
Character: Cute, friendly design inspired by the persona "${nickname}"

If a reference photo is provided, make the character resemble that person's features.
Add small decorative elements around the character that hint at ${genres} games (weapons, magic effects, game items, etc.)

Remember: ABSOLUTELY NO TEXT OR LETTERS IN THE IMAGE!`;

            // Prepare request body
            const requestBody = {
                contents: [{
                    parts: []
                }],
                generationConfig: {
                    responseModalities: ["Text", "Image"]
                }
            };

            // If user uploaded an image, include it
            if (aiProfileUploadedImage.value && aiProfilePreview.value) {
                const base64Data = aiProfilePreview.value.split(',')[1];
                const mimeType = aiProfileUploadedImage.value.type;
                
                requestBody.contents[0].parts.push({
                    inlineData: {
                        mimeType: mimeType,
                        data: base64Data
                    }
                });
            }

            // Add text prompt
            requestBody.contents[0].parts.push({
                text: prompt
            });

            // Call the backend API (which proxies to Gemini)
            const response = await fetch('/users/api/generate-ai-profile/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error('AI ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }

            const data = await response.json();
            
            if (data.image_base64) {
                aiProfileResult.value = `data:image/png;base64,${data.image_base64}`;
                aiProfileGenerated.value = true;
            } else {
                throw new Error('ìƒì„±ëœ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('AI Profile generation error:', error);
            alert('AI í”„ë¡œí•„ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
        } finally {
            isGeneratingAiProfile.value = false;
        }
    };

    const applyAiProfile = async () => {
        if (!aiProfileResult.value) return;
        
        try {
            // Convert base64 to blob
            const response = await fetch(aiProfileResult.value);
            const blob = await response.blob();
            
            // Create FormData
            const formData = new FormData();
            formData.append('avatar', blob, 'ai-profile.png');
            
            // Upload to server
            const uploadResponse = await fetch('/users/api/avatar/upload/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: formData
            });
            
            if (uploadResponse.ok) {
                const data = await uploadResponse.json();
                user.value.avatar = data.avatar_url;
                showAiProfileModal.value = false;
                resetAiProfile();
                alert('AI í”„ë¡œí•„ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!');
            } else {
                throw new Error('í”„ë¡œí•„ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('Apply AI profile error:', error);
            alert('í”„ë¡œí•„ ì ìš© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
        }
    };

    const resetAiProfile = () => {
        aiProfileGenerated.value = false;
        aiProfileResult.value = '';
        aiProfileUploadedImage.value = null;
        aiProfilePreview.value = '';
    };

    // Fetch user's top genres from ratings (for AI prompt)
    const fetchUserTopGenres = async () => {
        try {
            const response = await fetch('/users/api/genre-analysis/');
            if (response.ok) {
                const data = await response.json();
                if (data.genres && data.genres.length > 0) {
                    userTopGenres.value = data.genres.slice(0, 5).map(g => g.name);
                }
            }
        } catch (e) {
            console.log('Failed to fetch user genres for AI profile');
        }
    };

    // Fetch genres when modal opens
    Vue.watch(showAiProfileModal, (show) => {
        if (show && userTopGenres.value.length === 0) {
            fetchUserTopGenres();
        }
    });

    // Password verification for settings page
    const verifyPasswordAndGoToSettings = async () => {
        if (!verifyPassword.value) return;
        
        isVerifyingPassword.value = true;
        passwordVerifyError.value = '';
        
        try {
            const response = await fetch('/users/api/verify-password/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ password: verifyPassword.value })
            });
            
            const data = await response.json();
            
            if (response.ok && data.valid) {
                // Password verified, redirect to settings page
                showPasswordVerifyModal.value = false;
                verifyPassword.value = '';
                
                // Navigate to settings page with token
                window.location.href = `/users/settings/?token=${data.token}`;
            } else {
                passwordVerifyError.value = data.error || 'ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
            }
        } catch (error) {
            console.error('Password verification error:', error);
            passwordVerifyError.value = 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        } finally {
            isVerifyingPassword.value = false;
        }
    };


    const setupSteamInfiniteScroll = () => {
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && currentTab.value === 'home' && hasMoreSteamRecommendations.value) {
                loadMoreSteamRecommendations();
            }
        }, { threshold: 0.1, rootMargin: '100px' });

        // Watch for changes (e.g. tab switch)
        Vue.watch(steamScrollTrigger, (el) => {
            if (el) observer.observe(el);
        });

        // Observe immediately if already present
        if (steamScrollTrigger.value) {
            observer.observe(steamScrollTrigger.value);
        }
    };

    // Watch for tab change to load recommendations and update URL hash
    Vue.watch(currentTab, (newTab) => {
        // Update URL hash for tab persistence
        window.history.replaceState(null, '', `#${newTab}`);

        // Load recommendations if needed
        if (newTab === 'recommend' && recommendations.value.length === 0) {
            fetchRecommendations();
        }
    });

    // --- AI Chatbot Methods ---
    const scrollToBottom = () => {
        if (chatContainer.value) {
            setTimeout(() => {
                chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
            }, 100);
        }
    };

    const formatAIMessage = (content) => {
        if (!content) return '';
        // Convert markdown-style bold to HTML
        let formatted = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        // Convert line breaks
        formatted = formatted.replace(/\n/g, '<br>');
        return formatted;
    };

    const sendAiMessage = async () => {
        const message = aiUserInput.value.trim();
        if (!message || isAiLoading.value) return;

        // Add user message to chat
        aiChatMessages.value.push({
            role: 'user',
            content: message
        });

        aiUserInput.value = '';
        aiError.value = '';
        isAiLoading.value = true;
        scrollToBottom();

        try {
            const response = await fetch('/users/api/ai-chat/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    message: message,
                    history: aiChatMessages.value.slice(0, -1) // Exclude current message
                })
            });

            const data = await response.json();

            if (data.success && data.message) {
                aiChatMessages.value.push({
                    role: 'assistant',
                    content: data.message
                });
            } else {
                aiError.value = data.error || 'AI ì‘ë‹µì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
            }
        } catch (e) {
            console.error('AI Chat Error:', e);
            aiError.value = 'ì„œë²„ì™€ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        } finally {
            isAiLoading.value = false;
            scrollToBottom();
        }
    };

    // --- Onboarding Methods (ì™“ì±  ìŠ¤íƒ€ì¼) ---

    // ì˜¨ë³´ë”© í•„ìš” ì—¬ë¶€ ì²´í¬ ë° ê¸°ì¡´ í‰ê°€ ë¡œë“œ
    const checkOnboardingStatus = async () => {
        try {
            const response = await fetch('/users/api/onboarding/status/');
            const data = await response.json();

            // ê¸°ì¡´ í‰ê°€ ë°ì´í„° ë¡œë“œ (DBì—ì„œ ê°€ì ¸ì˜´)
            if (data.ratings) {
                // rawg_idë¥¼ ìˆ«ìžë¡œ ë³€í™˜í•˜ì—¬ ì €ìž¥
                const loadedRatings = {};
                for (const [rawgId, score] of Object.entries(data.ratings)) {
                    loadedRatings[parseInt(rawgId)] = score;
                }
                onboardingRatings.value = loadedRatings;
                console.log(`Loaded ${Object.keys(loadedRatings).length} existing ratings from DB`);
            }

            // ê²Œìž„ ìƒì„¸ ì •ë³´ ìºì‹œ ì €ìž¥ (í”„ë¡œí•„ ëª¨ë‹¬ìš©)
            if (data.rated_games_info) {
                for (const [rawgId, info] of Object.entries(data.rated_games_info)) {
                    gameInfoCache.value[rawgId] = info;
                }
            }
            if (data.wishlisted_games_info) {
                for (const [rawgId, info] of Object.entries(data.wishlisted_games_info)) {
                    gameInfoCache.value[rawgId] = info;
                }
            }

            if (data.needs_onboarding) {
                // ì˜¨ë³´ë”©ì´ í•„ìš”í•˜ë©´ ë¨¼ì € Steam ê²½í—˜ ì§ˆë¬¸ ëª¨ë‹¬ í‘œì‹œ (í† ìŠ¤ ìŠ¤íƒ€ì¼)
                showSteamQuestionModal.value = true;
                onboardingCurrentStep.value = data.current_step || 0;
                // ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë¦¬ê±° (ì•½ê°„ ë”œë ˆì´ í›„)
                setTimeout(() => {
                    steamQuestionAnimating.value = true;
                }, 50);
            }
        } catch (e) {
            console.error('Onboarding status check failed:', e);
        }
    };


    // Steam ì§ˆë¬¸ â†’ "ë„¤, ë§Žì´ í•´ë´¤ì–´ìš”" í´ë¦­ í•¸ë“¤ëŸ¬
    const handleSteamQuestionYes = async () => {
        onboardingKoreanMode.value = false;  // Steam ê²Œìž„ ëª¨ë“œ

        // ì§ˆë¬¸ ëª¨ë‹¬ ë‹«ê¸°
        steamQuestionAnimating.value = false;
        await new Promise(r => setTimeout(r, 300));
        showSteamQuestionModal.value = false;

        // íŠ¸ëžœì§€ì…˜ ëª¨ë‹¬ í‘œì‹œ
        showSteamTransitionModal.value = true;
        setTimeout(() => {
            steamTransitionAnimating.value = true;
        }, 50);

        // 1.5ì´ˆ í›„ ì˜¨ë³´ë”© ì‹œìž‘
        setTimeout(async () => {
            steamTransitionAnimating.value = false;
            await new Promise(r => setTimeout(r, 300));
            showSteamTransitionModal.value = false;

            // ì˜¨ë³´ë”© ëª¨ë‹¬ í‘œì‹œ
            showOnboarding.value = true;
            await loadOnboardingGames(onboardingCurrentStep.value);
        }, 1500);
    };

    // Steam ì§ˆë¬¸ â†’ "ì•„ë‹ˆìš”" í´ë¦­ í•¸ë“¤ëŸ¬
    const handleSteamQuestionNo = async () => {
        onboardingKoreanMode.value = true;  // í•œêµ­ ê²Œìž„ ëª¨ë“œ

        // ì§ˆë¬¸ ëª¨ë‹¬ ë‹«ê¸°
        steamQuestionAnimating.value = false;
        await new Promise(r => setTimeout(r, 300));
        showSteamQuestionModal.value = false;

        // ë°”ë¡œ ì˜¨ë³´ë”© ì‹œìž‘ (í•œêµ­ ê²Œìž„ ëª¨ë“œ)
        showOnboarding.value = true;
        await loadOnboardingGames(onboardingCurrentStep.value);
    };



    // ì˜¨ë³´ë”© ê²Œìž„ ëª©ë¡ ë¡œë“œ (íŽ˜ì´ì§€ë„¤ì´ì…˜ ì§€ì›)
    const loadOnboardingGames = async (step, page = 1) => {
        isLoadingOnboarding.value = true;
        try {
            // korean_mode íŒŒë¼ë¯¸í„° ì¶”ê°€
            const koreanParam = onboardingKoreanMode.value ? '&korean_mode=true' : '';
            const response = await fetch(`/users/api/onboarding/games/?step=${step}&page=${page}${koreanParam}`);
            const data = await response.json();

            onboardingGames.value = data.games || [];
            onboardingStep.value = data.step_info;
            onboardingTotalSteps.value = data.total_steps || 5;

            // íŽ˜ì´ì§€ë„¤ì´ì…˜ ì •ë³´ ì—…ë°ì´íŠ¸
            if (data.pagination) {
                onboardingCurrentPage.value = data.pagination.current_page;
                onboardingTotalPages.value = data.pagination.total_pages;
                onboardingTotalGames.value = data.pagination.total_games;
            }

            if (data.is_complete) {
                // ëª¨ë“  ë‹¨ê³„ ì™„ë£Œ
                await completeOnboarding();
            }
        } catch (e) {
            console.error('Failed to load onboarding games:', e);
        } finally {
            isLoadingOnboarding.value = false;
        }
    };


    // ê²Œìž„ í‰ê°€
    const rateGame = async (game, score) => {
        try {
            // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì¦‰ê° ë°˜ì‘)
            onboardingRatings.value = {
                ...onboardingRatings.value,
                [game.rawg_id]: score
            };

            // ì„œë²„ì— ì €ìž¥
            await fetch('/users/api/onboarding/rate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    game_id: game.rawg_id,
                    game_title: game.title,
                    game_image: game.image,
                    score: score
                })
            });
        } catch (e) {
            console.error('Failed to save rating:', e);
        }
    };

    // ë‹¤ìŒ íŽ˜ì´ì§€
    const nextOnboardingPage = async () => {
        if (onboardingCurrentPage.value < onboardingTotalPages.value) {
            slideDirection.value = 'slide-left'; // ì™¼ìª½ìœ¼ë¡œ ìŠ¬ë¼ì´ë“œ (ë‹¤ìŒìœ¼ë¡œ)
            const nextPage = onboardingCurrentPage.value + 1;
            await loadOnboardingGames(onboardingCurrentStep.value, nextPage);
        }
    };

    // ì´ì „ íŽ˜ì´ì§€
    const prevOnboardingPage = async () => {
        if (onboardingCurrentPage.value > 1) {
            slideDirection.value = 'slide-right'; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¬ë¼ì´ë“œ (ì´ì „ìœ¼ë¡œ)
            const prevPage = onboardingCurrentPage.value - 1;
            await loadOnboardingGames(onboardingCurrentStep.value, prevPage);
        }
    };

    // íŠ¹ì • íŽ˜ì´ì§€ë¡œ ì´ë™
    const goToOnboardingPage = async (page) => {
        if (page >= 1 && page <= onboardingTotalPages.value) {
            // í˜„ìž¬ íŽ˜ì´ì§€ë³´ë‹¤ í° íŽ˜ì´ì§€ë¡œ ì´ë™í•˜ë©´ ì™¼ìª½ìœ¼ë¡œ, ìž‘ìœ¼ë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ
            slideDirection.value = page > onboardingCurrentPage.value ? 'slide-left' : 'slide-right';
            await loadOnboardingGames(onboardingCurrentStep.value, page);
        }
    };

    // íŽ˜ì´ì§€ ë²ˆí˜¸ ê³„ì‚° í—¬í¼ (í˜„ìž¬ íŽ˜ì´ì§€ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ í‘œì‹œ)
    const getPageNumber = (index) => {
        const current = onboardingCurrentPage.value;
        const total = onboardingTotalPages.value;

        // ìµœëŒ€ 5ê°œ íŽ˜ì´ì§€ í‘œì‹œ
        let start = Math.max(1, current - 2);
        let end = Math.min(total, start + 4);

        // ëì—ì„œ ì‹œìž‘ì  ì¡°ì •
        if (end - start < 4) {
            start = Math.max(1, end - 4);
        }

        return start + index - 1;
    };

    // ì˜¨ë³´ë”© ì™„ë£Œ
    const completeOnboarding = async () => {
        try {
            await fetch('/users/api/onboarding/complete/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ skipped: false })
            });
        } catch (e) {
            console.error('Failed to complete onboarding:', e);
        }
        showOnboarding.value = false;
    };

    // ì˜¨ë³´ë”© ì™„ë£Œ ì¤‘ ë¡œë”© ìƒíƒœ
    const isCompletingOnboarding = ref(false);

    // ì˜¨ë³´ë”© ì™„ë£Œ (ìœ ì‚¬ë„ ìž¬ê³„ì‚° í¬í•¨)
    const finishOnboarding = async () => {
        isCompletingOnboarding.value = true;
        try {
            const response = await fetch('/users/api/onboarding/complete/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    skipped: false,
                    recalculate: true // ìœ ì‚¬ë„ ìž¬ê³„ì‚° ìš”ì²­
                })
            });

            if (response.ok) {
                const data = await response.json();
                console.log('Onboarding completed:', data);

                // ì™„ë£Œ í›„ ì¶”ì²œ íƒ­ìœ¼ë¡œ ì´ë™ (ìœ ì‚¬ë„ ë°ì´í„°ê°€ ê°±ì‹ ë˜ì—ˆìœ¼ë¯€ë¡œ)
                window.location.href = '/#recommend';
                window.location.reload();
            }
        } catch (e) {
            console.error('Failed to complete onboarding:', e);
            isCompletingOnboarding.value = false;
        }
    };

    // ì˜¨ë³´ë”© ìŠ¤í‚µ
    const skipOnboarding = async () => {
        try {
            await fetch('/users/api/onboarding/complete/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ skipped: true })
            });
        } catch (e) {
            console.error('Failed to skip onboarding:', e);
        }
        showOnboarding.value = false;
    };

    // ì˜¨ë³´ë”© ë‹¤ì‹œ ì‹œìž‘ (ë§ˆì´íŽ˜ì´ì§€ì—ì„œ í˜¸ì¶œ) - Steam ì§ˆë¬¸ ëª¨ë‹¬ë¶€í„° ì‹œìž‘
    const restartOnboarding = async () => {
        onboardingCurrentStep.value = 0;
        // onboardingRatingsëŠ” ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ - ê¸°ì¡´ DB í‰ê°€ ìœ ì§€

        // Steam ì§ˆë¬¸ ëª¨ë‹¬ë¶€í„° ë‹¤ì‹œ ì‹œìž‘
        showSteamQuestionModal.value = true;
        setTimeout(() => {
            steamQuestionAnimating.value = true;
        }, 50);
    };


    // í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œ íŠ¸ë¦¬ê±°
    const triggerAvatarUpload = () => {
        if (avatarInput.value) {
            avatarInput.value.click();
        }
    };

    // í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬
    const handleAvatarUpload = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        // ì´ë¯¸ì§€ íŒŒì¼ ê²€ì¦
        if (!file.type.startsWith('image/')) {
            alert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.');
            return;
        }

        // íŒŒì¼ í¬ê¸° ê²€ì¦ (5MB ì œí•œ)
        if (file.size > 5 * 1024 * 1024) {
            alert('íŒŒì¼ í¬ê¸°ëŠ” 5MB ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
            return;
        }

        try {
            const formData = new FormData();
            formData.append('avatar', file);

            const response = await fetch('/users/api/avatar/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                user.value.avatar = data.avatar_url;
                alert('í”„ë¡œí•„ ì‚¬ì§„ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤!');
            } else {
                alert('í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (e) {
            console.error('Avatar upload error:', e);
            alert('í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    return {

        // State
        currentStep,
        currentTab,
        user,
        authForm,
        isLoginMode,
        popularGames,
        sortedSaleGames,
        displayedSaleGames,
        hasMoreSaleGames,
        saleItemsPerPage,
        currentSaleCount,
        saleSearchQuery,
        showScrollTopBtn,
        isLoadingMoreSales,
        infiniteScrollTrigger,
        popularGamesOnSale,
        isLoadingPopularGames,
        fetchPopularGames,
        bestPrices,
        sortBy,
        wishlist,
        gameTab,
        rawgGames,
        isLoadingGames,
        loadGameTab,
        communityPosts,
        isWritingPost,
        communityCategory,
        newPost,
        selectedPost,
        fileInput,

        // Steam Library State
        steamLibrary,
        steamTotalGames,
        steamTotalHours,
        isLoadingSteamLibrary,

        // Recommendation State
        recommendations,
        recommendSortBy,
        genreAnalysis,
        recommendationMessage,
        isLoadingRecommendations,
        sortedRecommendations,
        displayedRecommendations,
        hasMoreRecommendations,
        currentRecommendCount,
        isLoadingMoreRecommendations,
        infiniteScrollTriggerRecommend,

        // Community Methods
        fetchPosts,
        submitPost,
        handleFileUpload,
        openPostDetail,
        closePostDetail,
        newComment,
        showShareToast,
        submitComment,
        deleteComment,
        togglePostLike,
        sharePost,
        formatDate,

        // Methods
        toggleAuthMode,
        handleAuthAction,
        handleLogout,
        deleteAccount,
        socialLogin,
        toggleLink,
        toggleWishlist,
        isWishlisted,
        formatPrice,
        formatReviewCount,
        handleImageError,
        goToHome,
        goToProfile,
        openRawgGame,
        scrollToTop,
        loadMoreSaleGames,
        navigateToGameDetail,
        navigateToSteamStore,
        navigateToGameByTitle,
        gameListContainer,
        scrollGameList,
        bestPricesContainer,
        infiniteBestPrices,
        scrollBestPrices,
        popularGamesContainer,
        infinitePopularGames,
        scrollPopularGames,
        fetchSteamLibrary,
        fetchRecommendations,
        loadMoreRecommendations,

        // AI Chatbot State & Methods
        aiChatMessages,
        aiUserInput,
        isAiLoading,
        aiError,
        chatContainer,
        aiQuickSuggestions,
        sendAiMessage,
        formatAIMessage,

        // Onboarding State & Methods (ì™“ì±  ìŠ¤íƒ€ì¼)
        showOnboarding,
        isLoadingOnboarding,
        isCompletingOnboarding, // ì¶”ê°€ë¨
        onboardingGames,
        onboardingRatings,
        onboardingCurrentStep,
        onboardingTotalSteps,
        onboardingStep,
        // ì˜¨ë³´ë”© íŽ˜ì´ì§€ë„¤ì´ì…˜
        onboardingCurrentPage,
        onboardingTotalPages,
        onboardingTotalGames,
        slideDirection, // ìŠ¬ë¼ì´ë“œ ì• ë‹ˆë©”ì´ì…˜ ë°©í–¥
        rateGame,
        nextOnboardingPage,
        prevOnboardingPage,
        goToOnboardingPage,
        getPageNumber,
        skipOnboarding, // ë‚˜ì¤‘ì— í•˜ê¸°
        finishOnboarding, // í‰ê°€ ì™„ë£Œí•˜ê¸° (ì¶”ê°€ë¨)
        restartOnboarding,

        // Steam ê²½í—˜ ì§ˆë¬¸ ëª¨ë‹¬ (í† ìŠ¤ ìŠ¤íƒ€ì¼)
        showSteamQuestionModal,
        steamQuestionAnimating,
        showSteamTransitionModal,
        steamTransitionAnimating,
        onboardingKoreanMode,
        handleSteamQuestionYes,
        handleSteamQuestionNo,

        // Profile Page State & Methods
        showWishlistModal,
        showReviewsModal,
        showSteamLibraryModal,
        avatarInput,
        triggerAvatarUpload,
        handleAvatarUpload,

        // Profile Display (computed & state for dynamic profiles)
        isMe,
        displayUser,
        displayWishlist,
        displayRatings,
        displayWishlistDetails,
        displayRatingDetails,
        displaySteamLibrary,
        displaySteamTotalGames,
        displaySteamTotalHours,

        targetUsername,
        isLoadingProfile,
        fetchUserProfile,

        // Genre Analysis (Home Page)
        genreAnalysisData,
        isLoadingGenreAnalysis,
        genreChartGradient,
        fetchGenreAnalysis,

        // Steam-Style Recommendations
        steamRecommendations,
        steamRecommendationPage,
        hasMoreSteamRecommendations,
        isLoadingSteamRecommendations,
        fetchSteamRecommendations,
        loadMoreSteamRecommendations,
        steamScrollTrigger,
        hideRecommendation,

        // AI Profile Generation
        showAiProfileModal,
        aiProfileUploadedImage,
        aiProfilePreview,
        isGeneratingAiProfile,
        aiProfileGenerated,
        aiProfileResult,
        aiProfileInput,
        userTopGenres,
        handleAiProfileUpload,
        handleAiProfileDrop,
        removeAiProfileImage,
        generateAiProfile,
        applyAiProfile,
        resetAiProfile,

        // Password Verification (ê°œì¸ì •ë³´ ìˆ˜ì •)
        showPasswordVerifyModal,
        verifyPassword,
        showVerifyPassword,
        isVerifyingPassword,
        passwordVerifyError,
        verifyPasswordAndGoToSettings,

        // Header Search & Autocomplete
        headerSearchQuery,
        performHeaderSearch,
        searchSuggestions,
        showSearchSuggestions,
        onHeaderSearchInput,
        selectSearchSuggestion,
        hideSearchSuggestionsDelayed
    };

        }
    }).mount('#app');
</script>
{% endblock %}