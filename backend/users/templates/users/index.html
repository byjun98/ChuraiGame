{% extends 'users/base.html' %}

{% block content %}
<div id="app" class="min-h-screen flex flex-col relative">

    {% include 'users/components/header.html' %}

    <!-- Main Content Area -->
    <main class="flex-1 flex flex-col">

        {% include 'users/components/auth.html' %}

        <!-- PAGE 2: Main Dashboard -->
        <div v-else-if="currentStep === 'main'" key="main" class="max-w-5xl mx-auto px-4 sm:px-6 py-8 w-full">

            {% include 'users/components/home_tab.html' %}
            {% include 'users/components/recommend_tab.html' %}
            {% include 'users/components/sale_tab.html' %}
            {% include 'users/components/community_tab.html' %}
            {% include 'users/components/ai_recommend_tab.html' %}

        </div>

        {% include 'users/components/profile_tab.html' %}
    </main>

    {% include 'users/components/mobile_nav.html' %}

    <!-- Onboarding Modal (왓챠 스타일) -->
    {% include 'users/components/onboarding_modal.html' %}

</div>
{% endblock %}

{% block scripts %}
<script>
    const { createApp, ref, computed, onMounted, reactive } = Vue;

    createApp({
        setup() {
            // State
            const currentStep = ref('main'); // Forced main view for logged-in users
            const currentTab = ref('home'); // 'home', 'sale'
            const isLoginMode = ref(true); // Toggle between Login and Signup
            const user = ref({ nickname: '{{ user.nickname }}', email: '{{ user.email }}' }); // Inject Django user data
            const games = ref([]);
            const wishlist = ref([]);

            // RAWG Game Tabs State
            const gameTab = ref('popular');
            const rawgGames = ref([]);
            const isLoadingGames = ref(false);

            // Community State
            const communityPosts = ref([]);
            const isWritingPost = ref(false);
            const communityCategory = ref('all');
            const selectedPost = ref(null);
            const fileInput = ref(null);
            const newPost = reactive({ title: '', content: '', category: 'free', file: null });

            // Game List Container ref for scrolling
            const gameListContainer = ref(null);

            // Auth Form State
            const authForm = reactive({
                email: '',
                password: '',
                nickname: ''
            });

            // Sorting State
            const sortBy = ref('interest');

            // Infinite Scroll State for Sale Tab
            const saleItemsPerPage = ref(12);
            const currentSaleCount = ref(12);
            const saleSearchQuery = ref('');  // Search query for sale games
            const showScrollTopBtn = ref(false);
            const isLoadingMoreSales = ref(false);
            const infiniteScrollTrigger = ref(null);
            const popularGamesOnSale = ref([]);  // RAWG popular games on sale
            const isLoadingPopularGames = ref(false);
            const bestPrices = ref([]);  // Best historical prices
            const bestPricesContainer = ref(null);  // Ref for best prices scroll container
            const popularGamesContainer = ref(null);  // Ref for popular games scroll container

            // Steam Library State
            const steamLibrary = ref([]);
            const steamTotalGames = ref(0);
            const steamTotalHours = ref(0);
            const isLoadingSteamLibrary = ref(false);

            // Recommendation State
            const recommendations = ref([]);
            const recommendSortBy = ref('score');
            const genreAnalysis = ref(null);
            const recommendationMessage = ref('');
            const isLoadingRecommendations = ref(false);
            const currentRecommendCount = ref(12);
            const recommendItemsPerPage = ref(12);
            const isLoadingMoreRecommendations = ref(false);
            const infiniteScrollTriggerRecommend = ref(null);

            // AI Chatbot State
            const aiChatMessages = ref([]);
            const aiUserInput = ref('');
            const isAiLoading = ref(false);
            const aiError = ref('');
            const chatContainer = ref(null);
            const aiQuickSuggestions = ref([
                '액션 RPG 추천해줘',
                '혼자 할 수 있는 힐링 게임',
                '스토리가 좋은 게임',
                '친구랑 같이 할 게임',
                '인디 게임 추천'
            ]);

            // Onboarding State (왓챠 스타일)
            const showOnboarding = ref(false);
            const isLoadingOnboarding = ref(false);
            const onboardingGames = ref([]);
            const onboardingRatings = ref({});  // { gameId: score }
            const onboardingCurrentStep = ref(0);
            const onboardingTotalSteps = ref(5);
            const onboardingStep = ref(null);

            onMounted(async () => {
                // Initialize Game Data from Django
                // Use verbatim block or different delimiters if mixing Vue and Django extensively
                // Here we initialize from rawSaleData for demo purposes, but ideally this comes from views.py context

                const serverData = JSON.parse('{{ games_json|escapejs }}');
                if (serverData.length > 0) {
                    games.value = serverData.map(game => ({
                        ...game,
                        matchScore: Math.floor(Math.random() * (99 - 70) + 70),
                    }));
                } else {
                    console.log("No game data found.");
                }
                // Initialize Wishlist
                try {
                    const wishlistData = JSON.parse('{{ wishlist_json|escapejs }}');
                    wishlist.value = wishlistData;
                } catch (e) {
                    console.error("Wishlist init failed", e);
                }

                // Initialize Best Prices (historic best deals)
                try {
                    const bestPricesData = JSON.parse('{{ best_prices_json|escapejs }}');
                    bestPrices.value = bestPricesData;
                } catch (e) {
                    console.error("Best prices init failed", e);
                }

                // Fetch RAWG Popular Games for Sale tab
                fetchPopularGames();

                // URL Hash based tab navigation
                const validTabs = ['home', 'recommend', 'ai', 'sale', 'community'];
                const hash = window.location.hash.replace('#', '');
                if (validTabs.includes(hash)) {
                    currentTab.value = hash;
                }

                // Listen for hash changes (browser back/forward)
                window.addEventListener('hashchange', () => {
                    const newHash = window.location.hash.replace('#', '');
                    if (validTabs.includes(newHash)) {
                        currentTab.value = newHash;
                    }
                });

                // Load Default Tab Games
                await loadGameTab('popular');

                // Fetch Community Posts
                await fetchPosts();

                // Setup scroll listener for scroll-to-top button
                window.addEventListener('scroll', handleScroll);

                // Setup infinite scroll
                setupInfiniteScroll();

                // Check if user needs onboarding (Steam 미연동 사용자)
                checkOnboardingStatus();
            });

            const loadGameTab = async (tabName) => {
                gameTab.value = tabName;
                isLoadingGames.value = true;
                rawgGames.value = [];

                try {
                    let url = '/games/api/popular/?limit=50';
                    if (tabName === 'top-rated') {
                        url = '/games/api/top-rated/?limit=50';
                    } else if (tabName === 'new-releases') {
                        url = '/games/api/new-releases/?limit=50';
                    } else if (tabName === 'trending') {
                        url = '/games/api/trending/?limit=50';
                    }

                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.games) {
                        rawgGames.value = data.games;
                    }
                } catch (e) {
                    console.error("Failed to fetch games for tab " + tabName, e);
                } finally {
                    isLoadingGames.value = false;
                    // Reset scroll position when tab changes
                    if (gameListContainer.value) {
                        gameListContainer.value.scrollLeft = 0;
                    }
                }
            };

            // Scroll game list left or right
            const scrollGameList = (direction) => {
                if (!gameListContainer.value) return;
                const container = gameListContainer.value;
                const cardWidth = 256 + 20; // w-64 (256px) + gap-5 (20px)
                const scrollAmount = cardWidth * 3; // Scroll 3 cards at a time

                if (direction === 'left') {
                    container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                } else {
                    container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                }
            };

            // Fetch RAWG Popular Games and match with Steam Sale data
            const fetchPopularGames = async () => {
                if (isLoadingPopularGames.value) return;

                isLoadingPopularGames.value = true;
                try {
                    // Check if sale games data is loaded
                    console.log(`Sale games loaded: ${games.value.length}`);

                    if (games.value.length === 0) {
                        console.warn("No sale games loaded yet, cannot match");
                        popularGamesOnSale.value = [];
                        return;
                    }

                    // Fetch all-time popular games (no date filter) for sale matching
                    const response = await fetch('/games/api/popular/?limit=100&all_time=true');
                    const data = await response.json();

                    console.log(`RAWG popular games fetched: ${data.games?.length || 0}`);

                    if (data.games && data.games.length > 0) {
                        // Create a map of sale games by normalized title for fast lookup
                        const saleGamesMap = new Map();
                        games.value.forEach(saleGame => {
                            // Normalize title: lowercase, remove special chars
                            const normalizedTitle = saleGame.title
                                .toLowerCase()
                                .replace(/[®™©:!?'-]/g, '')
                                .replace(/\s+/g, ' ')
                                .trim();
                            saleGamesMap.set(normalizedTitle, saleGame);

                            // Also try shorter version (first part before -)
                            const shortTitle = normalizedTitle.split(/[\-–—]/)[0].trim();
                            if (shortTitle.length > 3 && !saleGamesMap.has(shortTitle)) {
                                saleGamesMap.set(shortTitle, saleGame);
                            }
                        });

                        // Match popular games with sale data
                        const matchedGames = [];
                        for (const rawgGame of data.games) {
                            const normalizedRawgTitle = rawgGame.title
                                .toLowerCase()
                                .replace(/[®™©:!?'-]/g, '')
                                .replace(/\s+/g, ' ')
                                .trim();

                            // Try exact match
                            let saleMatch = saleGamesMap.get(normalizedRawgTitle);

                            // Try short title match if no exact match
                            if (!saleMatch) {
                                const shortRawgTitle = normalizedRawgTitle.split(/[\-–—]/)[0].trim();
                                if (shortRawgTitle.length > 3) {
                                    saleMatch = saleGamesMap.get(shortRawgTitle);
                                }
                            }

                            // Try partial match (contains)
                            if (!saleMatch) {
                                for (const [saleTitle, saleGame] of saleGamesMap) {
                                    if (saleTitle.length > 5 && (normalizedRawgTitle.includes(saleTitle) || saleTitle.includes(normalizedRawgTitle))) {
                                        saleMatch = saleGame;
                                        break;
                                    }
                                }
                            }

                            if (saleMatch) {
                                matchedGames.push({
                                    ...rawgGame,
                                    discount_rate: saleMatch.discount_rate,
                                    current_price: saleMatch.current_price,
                                    original_price: saleMatch.original_price,
                                    steam_game_id: saleMatch.game_id,
                                    isOnSale: true
                                });

                                // Stop when we have enough matches
                                if (matchedGames.length >= 15) break;
                            }
                        }

                        popularGamesOnSale.value = matchedGames;
                        console.log(`Matched ${matchedGames.length} popular games with sale data`);
                    } else {
                        console.warn("No games returned from RAWG API");
                        popularGamesOnSale.value = [];
                    }
                } catch (e) {
                    console.error("Failed to fetch popular games", e);
                    popularGamesOnSale.value = [];
                } finally {
                    isLoadingPopularGames.value = false;
                }
            };

            // --- Computed ---
            const popularGames = computed(() => games.value.slice(0, 5));

            // Calculate recommendation score for sale games (similar to recommendation.py)
            const calculateSaleScore = (game) => {
                let score = 0;

                // 1. Steam Rating (40 points max)
                const steamRating = game.steam_rating || 0;
                if (steamRating > 0) {
                    // Scale: 70-100% rating → 0-40 points
                    score += Math.min(40, Math.max(0, (steamRating - 70) / 30 * 40));
                }

                // 2. Review count popularity (25 points max)
                const reviewCount = game.review_count || 0;
                if (reviewCount > 0) {
                    // Log scale for review count (more reviews = more trusted)
                    const logReviews = Math.log10(reviewCount + 1);
                    score += Math.min(25, logReviews * 5);
                }

                // 3. Discount rate (20 points max)
                const discountRate = game.discount_rate || 0;
                score += Math.min(20, discountRate * 100 * 0.2);

                // 4. Historical low bonus (15 points)
                if (game.is_historical_low) {
                    score += 15;
                }

                return Math.round(score * 10) / 10;
            };

            // Filter by search query first, then sort
            const filteredSaleGames = computed(() => {
                let filtered = [...games.value];

                // Apply search filter
                if (saleSearchQuery.value.trim()) {
                    const query = saleSearchQuery.value.toLowerCase().trim();
                    filtered = filtered.filter(game =>
                        game.title && game.title.toLowerCase().includes(query)
                    );
                }

                return filtered;
            });

            const sortedSaleGames = computed(() => {
                let sorted = [...filteredSaleGames.value];

                if (sortBy.value === 'interest') {
                    // Apply recommendation algorithm
                    sorted = sorted.map(game => ({
                        ...game,
                        saleScore: calculateSaleScore(game)
                    }));
                    sorted.sort((a, b) => b.saleScore - a.saleScore);
                } else if (sortBy.value === 'rating') {
                    sorted.sort((a, b) => (b.steam_rating || 0) - (a.steam_rating || 0));
                } else if (sortBy.value === 'discount') {
                    sorted.sort((a, b) => (b.discount_rate || 0) - (a.discount_rate || 0));
                } else if (sortBy.value === 'price_asc') {
                    sorted.sort((a, b) => (a.current_price || 0) - (b.current_price || 0));
                }

                return sorted;
            });

            // Displayed games with infinite scroll
            const displayedSaleGames = computed(() => {
                return sortedSaleGames.value.slice(0, currentSaleCount.value);
            });

            const hasMoreSaleGames = computed(() => {
                return currentSaleCount.value < sortedSaleGames.value.length;
            });

            // Recommendation computed properties
            const sortedRecommendations = computed(() => {
                let sorted = [...recommendations.value];
                if (recommendSortBy.value === 'score') {
                    sorted.sort((a, b) => (b.recommendation_score || 0) - (a.recommendation_score || 0));
                } else if (recommendSortBy.value === 'rating') {
                    sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0));
                } else if (recommendSortBy.value === 'sale') {
                    // Show on-sale games first, then by discount
                    sorted.sort((a, b) => {
                        if (a.is_on_sale && !b.is_on_sale) return -1;
                        if (!a.is_on_sale && b.is_on_sale) return 1;
                        return (b.discount_rate || 0) - (a.discount_rate || 0);
                    });
                }
                return sorted;
            });

            const displayedRecommendations = computed(() => {
                return sortedRecommendations.value.slice(0, currentRecommendCount.value);
            });

            const hasMoreRecommendations = computed(() => {
                return currentRecommendCount.value < sortedRecommendations.value.length;
            });

            // --- Methods for CRUD & Auth ---

            const toggleAuthMode = () => {
                isLoginMode.value = !isLoginMode.value;
                authForm.email = '';
                authForm.password = '';
                authForm.nickname = '';
            };

            const handleAuthAction = () => {
                // Backend Integration Note: 
                // Replace this with axios.post('/api/login/' or '/api/register/', authForm)

                if (!authForm.email || !authForm.password) {
                    alert('이메일과 비밀번호를 입력해주세요.');
                    return;
                }
                // ... implementation details ...
            };

            // Navigate to game detail page (for sale cards)
            const navigateToGameDetail = (event, gameId) => {
                // Don't navigate if user clicked on a button or link
                if (event.target.closest('a') || event.target.closest('button')) {
                    return;
                }
                window.location.href = `/games/${gameId}/`;
            };

            // Navigate to Steam store page (for sale cards - Steam AppID != RAWG ID)
            const navigateToSteamStore = (event, storeLink) => {
                // Don't navigate if user clicked on a button or link
                if (event.target.closest('a') || event.target.closest('button')) {
                    return;
                }
                if (storeLink) {
                    window.open(storeLink, '_blank');
                }
            };

            // Navigate to game detail by title (for sale cards - search RAWG by title)
            const navigateToGameByTitle = (event, title, steamAppId, cheapsharkUrl) => {
                // Don't navigate if user clicked on a button or link
                if (event.target.closest('a') || event.target.closest('button')) {
                    return;
                }
                // Pass title, steam appid, and cheapshark redirect URL as query params
                const params = new URLSearchParams();
                params.set('title', title);
                if (steamAppId) params.set('steam_appid', steamAppId);
                if (cheapsharkUrl) params.set('cheapshark_url', cheapsharkUrl);
                window.location.href = `/games/search/?${params.toString()}`;
            };

            // Infinite scroll for best prices (repeat items for infinite effect)
            const infiniteBestPrices = computed(() => {
                if (!bestPrices.value || bestPrices.value.length === 0) return [];
                // Repeat the list to create infinite scroll effect
                return [...bestPrices.value, ...bestPrices.value, ...bestPrices.value];
            });

            // Infinite scroll for popular games on sale (repeat items for infinite effect)
            const infinitePopularGames = computed(() => {
                if (!popularGamesOnSale.value || popularGamesOnSale.value.length === 0) return [];
                // Repeat the list to create infinite scroll effect
                return [...popularGamesOnSale.value, ...popularGamesOnSale.value, ...popularGamesOnSale.value];
            });

            // Scroll best prices list left or right
            const scrollBestPrices = (direction) => {
                if (!bestPricesContainer.value) return;
                const container = bestPricesContainer.value;
                const cardWidth = 256 + 16; // w-64 (256px) + gap-4 (16px)
                const scrollAmount = cardWidth * 3; // Scroll 3 cards at a time
                const maxScroll = container.scrollWidth - container.clientWidth;

                if (direction === 'left') {
                    if (container.scrollLeft <= 0) {
                        // At the beginning, jump to end
                        container.scrollTo({ left: maxScroll / 2, behavior: 'auto' });
                    } else {
                        container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                    }
                } else {
                    if (container.scrollLeft >= maxScroll - 10) {
                        // At the end, jump to beginning
                        container.scrollTo({ left: maxScroll / 3, behavior: 'auto' });
                    } else {
                        container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                    }
                }
            };

            // Scroll popular games list left or right
            const scrollPopularGames = (direction) => {
                if (!popularGamesContainer.value) return;
                const container = popularGamesContainer.value;
                const cardWidth = 288 + 16; // w-72 (288px) + gap-4 (16px)
                const scrollAmount = cardWidth * 3; // Scroll 3 cards at a time
                const maxScroll = container.scrollWidth - container.clientWidth;

                if (direction === 'left') {
                    if (container.scrollLeft <= 0) {
                        // At the beginning, jump to end
                        container.scrollTo({ left: maxScroll / 2, behavior: 'auto' });
                    } else {
                        container.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                    }
                } else {
                    if (container.scrollLeft >= maxScroll - 10) {
                        // At the end, jump to beginning
                        container.scrollTo({ left: maxScroll / 3, behavior: 'auto' });
                    } else {
                        container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                    }
                }
            };

            const handleLogout = () => {
                // Redirect to Django logout URL
                window.location.href = "{% url 'users:logout' %}";
            };

            const deleteAccount = () => {
                // Redirect/Form submit to Django delete URL
                if (confirm("정말로 탈퇴하시겠습니까? 모든 데이터가 삭제됩니다.")) {
                    const form = document.createElement('form');
                    form.method = 'POST';
                    form.action = "{% url 'users:delete' %}";
                    const csrf = document.createElement('input');
                    csrf.type = 'hidden';
                    csrf.name = 'csrfmiddlewaretoken';
                    csrf.value = '{{ csrf_token }}';
                    form.appendChild(csrf);
                    document.body.appendChild(form);
                    form.submit();
                }
            };

            const socialLogin = (provider) => {
                alert(`${provider} 로그인 연동 기능은 준비 중입니다.`);
            };

            const toggleLink = (provider) => {
                // Toggle Linked Account Status (Update)
                if (provider === 'steam') {
                    user.value.linked_steam = !user.value.linked_steam;
                }
            };

            // --- Community Methods ---
            const newComment = ref('');
            const showShareToast = ref(false);

            const fetchPosts = async () => {
                try {
                    let url = '/community/posts/';
                    if (communityCategory.value !== 'all') {
                        url += `?category=${communityCategory.value}`;
                    }
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        communityPosts.value = data.map(post => ({
                            id: post.id,
                            title: post.title,
                            content: post.content,
                            author: post.author_name || '익명',
                            category: post.category,
                            created_at: new Date(post.created_at).toLocaleDateString(),
                            likes: post.likes_count || 0,
                            comments_count: post.comments_count || 0,
                            comments: (post.comments || []).map(c => ({
                                ...c,
                                is_own: c.author_name === user.value.nickname
                            })),
                            image_url: post.image_url || null,
                            video: post.video || null,
                            is_liked: post.is_liked || false
                        }));
                    }
                } catch (e) {
                    console.error("Failed to fetch posts", e);
                }
            };

            const handleFileUpload = (event) => {
                newPost.file = event.target.files[0];
            };

            const submitPost = async () => {
                if (!newPost.title || !newPost.content) return alert('제목과 내용을 입력해주세요.');

                try {
                    const formData = new FormData();
                    formData.append('title', newPost.title);
                    formData.append('content', newPost.content);
                    formData.append('category', newPost.category);
                    if (newPost.file) {
                        if (newPost.file.type.startsWith('image/')) {
                            formData.append('image', newPost.file);
                        } else if (newPost.file.type.startsWith('video/')) {
                            formData.append('video', newPost.file);
                        }
                    }

                    const response = await fetch('/community/posts/', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: formData
                    });

                    if (response.ok) {
                        isWritingPost.value = false;
                        newPost.title = '';
                        newPost.content = '';
                        newPost.file = null;
                        if (fileInput.value) fileInput.value.value = '';
                        await fetchPosts();
                    } else {
                        alert('게시글 작성 실패');
                    }
                } catch (e) {
                    console.error(e);
                }
            };

            const openPostDetail = async (post) => {
                // Fetch full post detail with comments
                try {
                    const response = await fetch(`/community/posts/${post.id}/`);
                    if (response.ok) {
                        const data = await response.json();
                        selectedPost.value = {
                            id: data.id,
                            title: data.title,
                            content: data.content,
                            author: data.author_name || '익명',
                            category: data.category,
                            created_at: new Date(data.created_at).toLocaleDateString(),
                            likes: data.likes_count || 0,
                            comments: (data.comments || []).map(c => ({
                                ...c,
                                is_own: c.author_name === user.value.nickname
                            })),
                            image_url: data.image_url || null,
                            video: data.video || null,
                            is_liked: data.is_liked || false
                        };
                    }
                } catch (e) {
                    console.error("Failed to fetch post detail", e);
                    selectedPost.value = post;
                }
                document.body.style.overflow = 'hidden';
            };

            const closePostDetail = () => {
                selectedPost.value = null;
                newComment.value = '';
                document.body.style.overflow = '';
            };

            const submitComment = async () => {
                if (!newComment.value.trim() || !selectedPost.value) return;

                try {
                    const response = await fetch(`/community/posts/${selectedPost.value.id}/comments/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ content: newComment.value })
                    });

                    if (response.ok) {
                        const comment = await response.json();
                        selectedPost.value.comments.push({
                            ...comment,
                            is_own: true
                        });
                        newComment.value = '';
                        // Update the post in the list
                        const postIndex = communityPosts.value.findIndex(p => p.id === selectedPost.value.id);
                        if (postIndex !== -1) {
                            communityPosts.value[postIndex].comments_count++;
                        }
                    } else {
                        alert('댓글 작성에 실패했습니다.');
                    }
                } catch (e) {
                    console.error("Failed to submit comment", e);
                }
            };

            const deleteComment = async (commentId) => {
                if (!confirm('댓글을 삭제하시겠습니까?')) return;

                try {
                    const response = await fetch(`/community/posts/${selectedPost.value.id}/comments/${commentId}/`, {
                        method: 'DELETE',
                        headers: {
                            'X-CSRFToken': '{{ csrf_token }}'
                        }
                    });

                    if (response.ok) {
                        selectedPost.value.comments = selectedPost.value.comments.filter(c => c.id !== commentId);
                        // Update the post in the list
                        const postIndex = communityPosts.value.findIndex(p => p.id === selectedPost.value.id);
                        if (postIndex !== -1) {
                            communityPosts.value[postIndex].comments_count--;
                        }
                    } else {
                        alert('댓글 삭제에 실패했습니다.');
                    }
                } catch (e) {
                    console.error("Failed to delete comment", e);
                }
            };

            const togglePostLike = async () => {
                if (!selectedPost.value) return;

                try {
                    const response = await fetch(`/community/posts/${selectedPost.value.id}/like/`, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': '{{ csrf_token }}'
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        selectedPost.value.is_liked = data.is_liked;
                        selectedPost.value.likes = data.likes_count;
                        // Update the post in the list
                        const postIndex = communityPosts.value.findIndex(p => p.id === selectedPost.value.id);
                        if (postIndex !== -1) {
                            communityPosts.value[postIndex].is_liked = data.is_liked;
                            communityPosts.value[postIndex].likes = data.likes_count;
                        }
                    }
                } catch (e) {
                    console.error("Failed to toggle like", e);
                }
            };

            const sharePost = async () => {
                if (!selectedPost.value) return;

                const shareUrl = `${window.location.origin}/community/posts/${selectedPost.value.id}/`;

                try {
                    await navigator.clipboard.writeText(shareUrl);
                    showShareToast.value = true;
                    setTimeout(() => {
                        showShareToast.value = false;
                    }, 2000);
                } catch (e) {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showShareToast.value = true;
                    setTimeout(() => {
                        showShareToast.value = false;
                    }, 2000);
                }
            };

            const formatDate = (dateString) => {
                return new Date(dateString).toLocaleDateString();
            };

            // Watch category change
            Vue.watch(communityCategory, () => {
                fetchPosts();
            });

            // --- Feature Methods ---

            const toggleWishlist = (game) => {
                const index = wishlist.value.findIndex(id => id === game.game_id);
                if (index === -1) {
                    wishlist.value.push(game.game_id);
                } else {
                    wishlist.value.splice(index, 1);
                }
            };

            const isWishlisted = (gameId) => {
                return wishlist.value.includes(gameId);
            };

            const formatPrice = (price) => price ? price.toLocaleString() : '무료';
            const formatReviewCount = (count) => {
                if (!count) return '0';
                if (count >= 100000) return Math.round(count / 1000) + 'K';
                if (count >= 10000) return (count / 1000).toFixed(1) + 'K';
                if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
                return count.toLocaleString();
            };
            const handleImageError = (e) => { e.target.src = "https://via.placeholder.com/460x215?text=No+Image"; };
            const goToHome = () => {
                currentStep.value = 'main';
                currentTab.value = 'home';
            };

            const openRawgGame = (game) => {
                if (!game) return;

                // rawg_id가 있으면 RAWG 기반 상세 페이지로
                if (game.rawg_id) {
                    window.location.href = `/games/${game.rawg_id}/`;
                }
                // 게임 제목이 있으면 검색 페이지로
                else if (game.title) {
                    const params = new URLSearchParams({ title: game.title });
                    window.location.href = `/games/search/?${params.toString()}`;
                }
            };


            // --- Infinite Scroll Methods ---
            const scrollToTop = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            const loadMoreSaleGames = () => {
                if (isLoadingMoreSales.value || !hasMoreSaleGames.value) return;

                isLoadingMoreSales.value = true;
                setTimeout(() => {
                    currentSaleCount.value += saleItemsPerPage.value;
                    isLoadingMoreSales.value = false;
                }, 300); // Small delay for smooth UX
            };

            const setupInfiniteScroll = () => {
                // Observer for Sale tab
                const saleObserver = new IntersectionObserver((entries) => {
                    if (entries[0].isIntersecting && currentTab.value === 'sale') {
                        loadMoreSaleGames();
                    }
                }, { threshold: 0.1 });

                // Observer for Recommend tab
                const recommendObserver = new IntersectionObserver((entries) => {
                    if (entries[0].isIntersecting && currentTab.value === 'recommend') {
                        loadMoreRecommendations();
                    }
                }, { threshold: 0.1 });

                // Watch for the sale trigger element
                Vue.watch(infiniteScrollTrigger, (el) => {
                    if (el) saleObserver.observe(el);
                });

                // Watch for the recommend trigger element
                Vue.watch(infiniteScrollTriggerRecommend, (el) => {
                    if (el) recommendObserver.observe(el);
                });
            };

            // Scroll position watcher
            const handleScroll = () => {
                showScrollTopBtn.value = window.scrollY > 300;
            };

            // Reset count when items per page changes
            Vue.watch(saleItemsPerPage, (newVal) => {
                currentSaleCount.value = newVal;
            });

            // Reset count when sort changes
            Vue.watch(sortBy, () => {
                currentSaleCount.value = saleItemsPerPage.value;
            });

            // Reset count when search query changes
            Vue.watch(saleSearchQuery, () => {
                currentSaleCount.value = saleItemsPerPage.value;
            });

            // --- Steam Library Methods ---
            const fetchSteamLibrary = async () => {
                if (isLoadingSteamLibrary.value) return;

                isLoadingSteamLibrary.value = true;
                try {
                    const response = await fetch('/users/api/steam/library/');
                    if (response.ok) {
                        const data = await response.json();
                        steamLibrary.value = data.library || [];
                        steamTotalGames.value = data.total_games || 0;
                        steamTotalHours.value = data.total_playtime_hours || 0;
                    } else {
                        console.error('Failed to fetch Steam library');
                    }
                } catch (e) {
                    console.error('Error fetching Steam library:', e);
                } finally {
                    isLoadingSteamLibrary.value = false;
                }
            };

            // --- Recommendation Methods ---
            const fetchRecommendations = async () => {
                if (isLoadingRecommendations.value) return;

                isLoadingRecommendations.value = true;
                recommendations.value = [];

                try {
                    const response = await fetch('/users/api/recommendations/');
                    if (response.ok) {
                        const data = await response.json();
                        recommendations.value = data.recommendations || [];
                        genreAnalysis.value = data.genres_analysis || null;
                        recommendationMessage.value = data.message || '';
                        currentRecommendCount.value = recommendItemsPerPage.value;
                    } else {
                        console.error('Failed to fetch recommendations');
                    }
                } catch (e) {
                    console.error('Error fetching recommendations:', e);
                } finally {
                    isLoadingRecommendations.value = false;
                }
            };

            const loadMoreRecommendations = () => {
                if (isLoadingMoreRecommendations.value || !hasMoreRecommendations.value) return;

                isLoadingMoreRecommendations.value = true;
                setTimeout(() => {
                    currentRecommendCount.value += recommendItemsPerPage.value;
                    isLoadingMoreRecommendations.value = false;
                }, 300);
            };

            // Watch for tab change to load recommendations and update URL hash
            Vue.watch(currentTab, (newTab) => {
                // Update URL hash for tab persistence
                window.history.replaceState(null, '', `#${newTab}`);

                // Load recommendations if needed
                if (newTab === 'recommend' && recommendations.value.length === 0) {
                    fetchRecommendations();
                }
            });

            // --- AI Chatbot Methods ---
            const scrollToBottom = () => {
                if (chatContainer.value) {
                    setTimeout(() => {
                        chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
                    }, 100);
                }
            };

            const formatAIMessage = (content) => {
                if (!content) return '';
                // Convert markdown-style bold to HTML
                let formatted = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                // Convert line breaks
                formatted = formatted.replace(/\n/g, '<br>');
                return formatted;
            };

            const sendAiMessage = async () => {
                const message = aiUserInput.value.trim();
                if (!message || isAiLoading.value) return;

                // Add user message to chat
                aiChatMessages.value.push({
                    role: 'user',
                    content: message
                });

                aiUserInput.value = '';
                aiError.value = '';
                isAiLoading.value = true;
                scrollToBottom();

                try {
                    const response = await fetch('/users/api/ai-chat/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            message: message,
                            history: aiChatMessages.value.slice(0, -1) // Exclude current message
                        })
                    });

                    const data = await response.json();

                    if (data.success && data.message) {
                        aiChatMessages.value.push({
                            role: 'assistant',
                            content: data.message
                        });
                    } else {
                        aiError.value = data.error || 'AI 응답을 받지 못했습니다.';
                    }
                } catch (e) {
                    console.error('AI Chat Error:', e);
                    aiError.value = '서버와 통신 중 오류가 발생했습니다.';
                } finally {
                    isAiLoading.value = false;
                    scrollToBottom();
                }
            };

            // --- Onboarding Methods (왓챠 스타일) ---

            // 온보딩 필요 여부 체크
            const checkOnboardingStatus = async () => {
                try {
                    const response = await fetch('/users/api/onboarding/status/');
                    const data = await response.json();

                    if (data.needs_onboarding) {
                        // 온보딩이 필요하면 모달 표시
                        showOnboarding.value = true;
                        onboardingCurrentStep.value = data.current_step || 0;
                        await loadOnboardingGames(onboardingCurrentStep.value);
                    }
                } catch (e) {
                    console.error('Onboarding status check failed:', e);
                }
            };

            // 온보딩 게임 목록 로드
            const loadOnboardingGames = async (step) => {
                isLoadingOnboarding.value = true;
                try {
                    const response = await fetch(`/users/api/onboarding/games/?step=${step}`);
                    const data = await response.json();

                    onboardingGames.value = data.games || [];
                    onboardingStep.value = data.step_info;
                    onboardingTotalSteps.value = data.total_steps || 5;

                    if (data.is_complete) {
                        // 모든 단계 완료
                        await completeOnboarding();
                    }
                } catch (e) {
                    console.error('Failed to load onboarding games:', e);
                } finally {
                    isLoadingOnboarding.value = false;
                }
            };

            // 게임 평가
            const rateGame = async (game, score) => {
                try {
                    // 로컬 상태 업데이트 (즉각 반응)
                    onboardingRatings.value = {
                        ...onboardingRatings.value,
                        [game.rawg_id]: score
                    };

                    // 서버에 저장
                    await fetch('/users/api/onboarding/rate/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({
                            game_id: game.rawg_id,
                            game_title: game.title,
                            game_image: game.image,
                            score: score
                        })
                    });
                } catch (e) {
                    console.error('Failed to save rating:', e);
                }
            };

            // 다음 단계
            const nextOnboardingStep = async () => {
                const nextStep = onboardingCurrentStep.value + 1;

                if (nextStep >= onboardingTotalSteps.value) {
                    // 마지막 단계 완료
                    await completeOnboarding();
                } else {
                    onboardingCurrentStep.value = nextStep;

                    // 서버에 진행 상황 저장
                    await fetch('/users/api/onboarding/next-step/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ step: nextStep })
                    });

                    // 다음 단계 게임 로드
                    await loadOnboardingGames(nextStep);
                }
            };

            // 이전 단계
            const prevOnboardingStep = async () => {
                if (onboardingCurrentStep.value > 0) {
                    const prevStep = onboardingCurrentStep.value - 1;
                    onboardingCurrentStep.value = prevStep;
                    await loadOnboardingGames(prevStep);
                }
            };

            // 온보딩 완료
            const completeOnboarding = async () => {
                try {
                    await fetch('/users/api/onboarding/complete/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ skipped: false })
                    });
                } catch (e) {
                    console.error('Failed to complete onboarding:', e);
                }
                showOnboarding.value = false;
            };

            // 온보딩 스킵
            const skipOnboarding = async () => {
                try {
                    await fetch('/users/api/onboarding/complete/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: JSON.stringify({ skipped: true })
                    });
                } catch (e) {
                    console.error('Failed to skip onboarding:', e);
                }
                showOnboarding.value = false;
            };

            // 온보딩 다시 시작 (마이페이지에서 호출)
            const restartOnboarding = async () => {
                onboardingCurrentStep.value = 0;
                onboardingRatings.value = {};
                showOnboarding.value = true;
                await loadOnboardingGames(0);
            };

            return {

                // State
                currentStep,
                currentTab,
                user,
                authForm,
                isLoginMode,
                popularGames,
                sortedSaleGames,
                displayedSaleGames,
                hasMoreSaleGames,
                saleItemsPerPage,
                currentSaleCount,
                saleSearchQuery,
                showScrollTopBtn,
                isLoadingMoreSales,
                infiniteScrollTrigger,
                popularGamesOnSale,
                isLoadingPopularGames,
                fetchPopularGames,
                bestPrices,
                sortBy,
                wishlist,
                gameTab,
                rawgGames,
                isLoadingGames,
                loadGameTab,
                communityPosts,
                isWritingPost,
                communityCategory,
                newPost,
                selectedPost,
                fileInput,

                // Steam Library State
                steamLibrary,
                steamTotalGames,
                steamTotalHours,
                isLoadingSteamLibrary,

                // Recommendation State
                recommendations,
                recommendSortBy,
                genreAnalysis,
                recommendationMessage,
                isLoadingRecommendations,
                sortedRecommendations,
                displayedRecommendations,
                hasMoreRecommendations,
                currentRecommendCount,
                isLoadingMoreRecommendations,
                infiniteScrollTriggerRecommend,

                // Community Methods
                fetchPosts,
                submitPost,
                handleFileUpload,
                openPostDetail,
                closePostDetail,
                newComment,
                showShareToast,
                submitComment,
                deleteComment,
                togglePostLike,
                sharePost,
                formatDate,

                // Methods
                toggleAuthMode,
                handleAuthAction,
                handleLogout,
                deleteAccount,
                socialLogin,
                toggleLink,
                toggleWishlist,
                isWishlisted,
                formatPrice,
                formatReviewCount,
                handleImageError,
                goToHome,
                openRawgGame,
                scrollToTop,
                loadMoreSaleGames,
                navigateToGameDetail,
                navigateToSteamStore,
                navigateToGameByTitle,
                gameListContainer,
                scrollGameList,
                bestPricesContainer,
                infiniteBestPrices,
                scrollBestPrices,
                popularGamesContainer,
                infinitePopularGames,
                scrollPopularGames,
                fetchSteamLibrary,
                fetchRecommendations,
                loadMoreRecommendations,

                // AI Chatbot State & Methods
                aiChatMessages,
                aiUserInput,
                isAiLoading,
                aiError,
                chatContainer,
                aiQuickSuggestions,
                sendAiMessage,
                formatAIMessage,

                // Onboarding State & Methods (왓챠 스타일)
                showOnboarding,
                isLoadingOnboarding,
                onboardingGames,
                onboardingRatings,
                onboardingCurrentStep,
                onboardingTotalSteps,
                onboardingStep,
                rateGame,
                nextOnboardingStep,
                prevOnboardingStep,
                skipOnboarding,
                restartOnboarding
            };

        }
    }).mount('#app');
</script>
{% endblock %}